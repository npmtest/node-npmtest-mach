{"/home/travis/build/npmtest/node-npmtest-mach/test.js":"/* istanbul instrument in package npmtest_mach */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mach/lib.npmtest_mach.js":"/* istanbul instrument in package npmtest_mach */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mach = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mach = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mach/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mach && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mach */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mach\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mach.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_mach.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mach.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_mach.__dirname + '/lib.npmtest_mach.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/index.js":"\"use strict\";\n\nvar EXTENSIONS = [];\n\n/*!\n * mach - HTTP for JavaScript\n * https://github.com/mjackson/mach\n */\nvar mach = module.exports = {\n\n  version: require(\"./version\"),\n  Connection: require(\"./Connection\"),\n  Header: require(\"./Header\"),\n  Location: require(\"./Location\"),\n  Message: require(\"./Message\"),\n\n  extend: function extend() {\n    var extension;\n    for (var i = 0, len = arguments.length; i < len; ++i) {\n      extension = arguments[i];\n\n      if (EXTENSIONS.indexOf(extension) === -1) {\n        EXTENSIONS.push(extension);\n        extension(mach);\n      }\n    }\n  }\n\n};\n\nmach.extend(require(\"./extensions/default\"));","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/version.js":"\"use strict\";\n\n/**\n * The current version of mach.\n */\nmodule.exports = \"1.3.5\";","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/Connection.js":"\"use strict\";\n\n/* jshint -W058 */\nvar d = require(\"describe-property\");\nvar isBinary = require(\"bodec\").isBinary;\nvar decodeBase64 = require(\"./utils/decodeBase64\");\nvar encodeBase64 = require(\"./utils/encodeBase64\");\nvar stringifyQuery = require(\"./utils/stringifyQuery\");\nvar Promise = require(\"./utils/Promise\");\nvar Location = require(\"./Location\");\nvar Message = require(\"./Message\");\n\nfunction locationPropertyAlias(name) {\n  return d.gs(function () {\n    return this.location[name];\n  }, function (value) {\n    this.location[name] = value;\n  });\n}\n\nfunction defaultErrorHandler(error) {\n  if (typeof console !== \"undefined\" && console.error) {\n    console.error(error && error.stack || error);\n  } else {\n    throw error; // Don't silently swallow errors!\n  }\n}\n\nfunction defaultCloseHandler() {}\n\nfunction defaultApp(conn) {\n  conn.status = 404;\n  conn.response.contentType = \"text/plain\";\n  conn.response.content = \"Not found: \" + conn.method + \" \" + conn.path;\n}\n\n/**\n * An HTTP connection that acts as the asynchronous primitive for\n * the duration of the request/response cycle.\n *\n * Important features are:\n *\n * - request        A Message representing the request being made. In\n *                  a server environment, this is an \"incoming\" message\n *                  that was probably generated by a web browser or some\n *                  other consumer. In a client environment, this is an\n *                  \"outgoing\" message that we send to a remote server.\n * - response       A Message representing the response to the request.\n *                  In a server environment, this is an \"outgoing\" message\n *                  that will be sent back to the client. In a client\n *                  environment, this is the response that was received\n *                  from the remote server.\n * - method         The HTTP method that the request uses\n * - location       The URL of the request. In a server environment, this\n *                  is derived from the URL path used in the request as\n *                  well as a combination of the Host, X-Forwarded-* and\n *                  other relevant headers.\n * - version        The version of HTTP used in the request\n * - status         The HTTP status code of the response\n * - statusText     The HTTP status text that corresponds to the status\n * - responseText   This is a special property that contains the entire\n *                  content of the response. It is present by default when\n *                  making client requests for convenience, but may also be\n *                  disabled when you need to stream the response.\n *\n * Options may be any of the following:\n *\n * - content        The request content, defaults to \"\"\n * - headers        The request headers, defaults to {}\n * - method         The request HTTP method, defaults to \"GET\"\n * - location/url   The request Location or URL\n * - params         The request params\n * - onError        A function that is called when there is an error\n * - onClose        A function that is called when the request closes\n *\n * The options may also be a URL string to specify the URL.\n */\nfunction Connection(options) {\n  options = options || {};\n\n  var location;\n  if (typeof options === \"string\") {\n    location = options; // options may be a URL string.\n  } else if (options.location || options.url) {\n    location = options.location || options.url;\n  } else if (typeof window === \"object\") {\n    location = window.location.href;\n  }\n\n  this.location = location;\n  this.version = options.version || \"1.1\";\n  this.method = options.method;\n\n  this.onError = (options.onError || defaultErrorHandler).bind(this);\n  this.onClose = (options.onClose || defaultCloseHandler).bind(this);\n  this.request = new Message(options.content, options.headers);\n  this.response = new Message();\n\n  // Params may be given as an object.\n  if (options.params) {\n    if (this.method === \"GET\" || this.method === \"HEAD\") {\n      this.query = options.params;\n    } else {\n      this.request.contentType = \"application/x-www-form-urlencoded\";\n      this.request.content = stringifyQuery(options.params);\n    }\n  }\n\n  this.withCredentials = options.withCredentials || false;\n  this.remoteHost = options.remoteHost || null;\n  this.remoteUser = options.remoteUser || null;\n  this.basename = \"\";\n\n  this.responseText = null;\n  this.status = 200;\n}\n\nObject.defineProperties(Connection.prototype, {\n\n  /**\n   * The method used in the request.\n   */\n  method: d.gs(function () {\n    return this._method;\n  }, function (value) {\n    this._method = typeof value === \"string\" ? value.toUpperCase() : \"GET\";\n  }),\n\n  /**\n   * The Location of the request.\n   */\n  location: d.gs(function () {\n    return this._location;\n  }, function (value) {\n    this._location = value instanceof Location ? value : new Location(value);\n  }),\n\n  href: locationPropertyAlias(\"href\"),\n  protocol: locationPropertyAlias(\"protocol\"),\n  host: locationPropertyAlias(\"host\"),\n  hostname: locationPropertyAlias(\"hostname\"),\n  port: locationPropertyAlias(\"port\"),\n  search: locationPropertyAlias(\"search\"),\n  queryString: locationPropertyAlias(\"queryString\"),\n  query: locationPropertyAlias(\"query\"),\n\n  /**\n   * True if the request uses SSL, false otherwise.\n   */\n  isSSL: d.gs(function () {\n    return this.protocol === \"https:\";\n  }),\n\n  /**\n   * The username:password used in the request, an empty string\n   * if no auth was provided.\n   */\n  auth: d.gs(function () {\n    var header = this.request.headers.Authorization;\n\n    if (header) {\n      var parts = header.split(\" \", 2);\n      var scheme = parts[0];\n\n      if (scheme.toLowerCase() === \"basic\") return decodeBase64(parts[1]);\n\n      return header;\n    }\n\n    return this.location.auth;\n  }, function (value) {\n    var headers = this.request.headers;\n\n    if (value && typeof value === \"string\") {\n      headers.Authorization = \"Basic \" + encodeBase64(value);\n    } else {\n      delete headers.Authorization;\n    }\n  }),\n\n  /**\n   * The portion of the original URL path that is still relevant\n   * for request processing.\n   */\n  pathname: d.gs(function () {\n    return this.location.pathname.replace(this.basename, \"\") || \"/\";\n  }, function (value) {\n    this.location.pathname = this.basename + value;\n  }),\n\n  /**\n   * The URL path with query string.\n   */\n  path: d.gs(function () {\n    return this.pathname + this.search;\n  }, function (value) {\n    this.location.path = this.basename + value;\n  }),\n\n  /**\n   * Calls the given `app` with this connection as the only argument.\n   * as the first argument and returns a promise for a Response.\n   */\n  call: d(function (app) {\n    app = app || defaultApp;\n\n    var conn = this;\n\n    try {\n      return Promise.resolve(app(conn)).then(function (value) {\n        if (value == null) return;\n\n        if (typeof value === \"number\") {\n          conn.status = value;\n        } else if (typeof value === \"string\" || isBinary(value) || typeof value.pipe === \"function\") {\n          conn.response.content = value;\n        } else {\n          if (value.headers != null) conn.response.headers = value.headers;\n\n          if (value.content != null) conn.response.content = value.content;\n\n          if (value.status != null) conn.status = value.status;\n        }\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  })\n\n});\n\nmodule.exports = Connection;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/decodeBase64.js":"\"use strict\";\n\nmodule.exports = require(\"bodec\").decodeBase64;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/encodeBase64.js":"\"use strict\";\n\nmodule.exports = require(\"bodec\").encodeBase64;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/stringifyQuery.js":"\"use strict\";\n\nmodule.exports = require(\"qs\").stringify;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/Promise.js":"\"use strict\";\n\nvar Promise = require(\"when/lib/Promise\");\n\nif (process.env.NODE_ENV !== \"production\") require(\"when/monitor\")(Promise);\n\nmodule.exports = Promise;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/Location.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar mergeQuery = require(\"./utils/mergeQuery\");\nvar stringifyQuery = require(\"./utils/stringifyQuery\");\nvar parseQuery = require(\"./utils/parseQuery\");\nvar parseURL = require(\"./utils/parseURL\");\n\n/**\n * Standard ports for HTTP protocols.\n */\nvar STANDARD_PORTS = {\n  \"http:\": \"80\",\n  \"https:\": \"443\"\n};\n\nfunction propertyAlias(propertyName, defaultValue) {\n  return d.gs(function () {\n    return this.properties[propertyName] || (defaultValue == null ? null : defaultValue);\n  }, function (value) {\n    this.properties[propertyName] = value;\n  });\n}\n\n// Order is important here. Later properties take priority.\nvar PROPERTY_NAMES = [\"protocol\", \"auth\", \"hostname\", \"port\", \"host\", \"pathname\", \"search\", \"queryString\", \"query\", \"path\"];\n\nfunction setProperties(location, properties) {\n  var propertyName;\n  for (var i = 0, len = PROPERTY_NAMES.length; i < len; ++i) {\n    propertyName = PROPERTY_NAMES[i];\n\n    if (properties.hasOwnProperty(propertyName) && propertyName in location) location[propertyName] = properties[propertyName];\n  }\n}\n\n/**\n * A URL location, analogous to window.location.\n *\n * Options may be any of the following:\n *\n * - protocol\n * - auth\n * - hostname\n * - port\n * - host (overrides hostname and port)\n * - pathname\n * - search\n * - queryString (overrides search)\n * - query (overrides queryString/search)\n * - path (overrides pathname and query/queryString/search)\n *\n * Alternatively, options may be a URL string.\n */\nfunction Location(options) {\n  this.properties = {};\n\n  if (typeof options === \"string\") {\n    this.href = options;\n  } else if (options) {\n    setProperties(this, options);\n  }\n}\n\nObject.defineProperties(Location.prototype, {\n\n  /**\n   * Creates and returns a new Location with the path and query of\n   * the given location appended.\n   */\n  concat: d(function (location) {\n    if (!(location instanceof Location)) location = new Location(location);\n\n    var pathname = this.pathname;\n    var extraPathname = location.pathname;\n\n    if (extraPathname !== \"/\") pathname = pathname.replace(/\\/*$/, \"/\") + extraPathname.replace(/^\\/*/, \"\");\n\n    var query = mergeQuery(this.query, location.query);\n\n    return new Location({\n      protocol: location.protocol || this.protocol,\n      auth: location.auth || this.auth,\n      hostname: location.hostname || this.hostname,\n      port: location.port || this.port,\n      pathname: pathname,\n      query: query\n    });\n  }),\n\n  /**\n   * The full URL.\n   */\n  href: d.gs(function () {\n    var auth = this.auth;\n    var host = this.host;\n    var path = this.path;\n\n    return host ? this.protocol + \"//\" + (auth ? auth + \"@\" : \"\") + host + path : path;\n  }, function (value) {\n    var parsed = parseURL(value);\n\n    setProperties(this, {\n      protocol: parsed.protocol,\n      auth: parsed.auth,\n      hostname: parsed.hostname,\n      port: parsed.port,\n      pathname: parsed.pathname,\n      search: parsed.search\n    });\n  }),\n\n  /**\n   * The portion of the URL that denotes the protocol, including the\n   * trailing colon (e.g. \"http:\" or \"https:\").\n   */\n  protocol: propertyAlias(\"protocol\"),\n\n  /**\n   * The username:password used in the URL, if any.\n   */\n  auth: propertyAlias(\"auth\", \"\"),\n\n  /**\n   * The full name of the host, including the port number when using\n   * a non-standard port.\n   */\n  host: d.gs(function () {\n    var protocol = this.protocol;\n    var host = this.hostname;\n    var port = this.port;\n\n    if (port != null && port !== STANDARD_PORTS[protocol]) host += \":\" + port;\n\n    return host;\n  }, function (value) {\n    var index;\n\n    if (typeof value === \"string\" && (index = value.indexOf(\":\")) !== -1) {\n      this.hostname = value.substring(0, index);\n      this.port = value.substring(index + 1);\n    } else {\n      this.hostname = value;\n      this.port = null;\n    }\n  }),\n\n  /**\n   * The name of the host without the port.\n   */\n  hostname: propertyAlias(\"hostname\"),\n\n  /**\n   * The port number as a string.\n   */\n  port: d.gs(function () {\n    return this.properties.port || (this.protocol ? STANDARD_PORTS[this.protocol] : null);\n  }, function (value) {\n    this.properties.port = value ? String(value) : null;\n  }),\n\n  /**\n   * The URL path without the query string.\n   */\n  pathname: propertyAlias(\"pathname\", \"/\"),\n\n  /**\n   * The URL path with query string.\n   */\n  path: d.gs(function () {\n    return this.pathname + this.search;\n  }, function (value) {\n    var index;\n\n    if (typeof value === \"string\" && (index = value.indexOf(\"?\")) !== -1) {\n      this.pathname = value.substring(0, index);\n      this.search = value.substring(index);\n    } else {\n      this.pathname = value;\n      this.search = null;\n    }\n  }),\n\n  /**\n   * The query string, including the preceeding ?.\n   */\n  search: propertyAlias(\"search\", \"\"),\n\n  /**\n   * The query string of the URL, without the preceeding ?.\n   */\n  queryString: d.gs(function () {\n    return this.search.substring(1);\n  }, function (value) {\n    this.search = value && \"?\" + value;\n  }),\n\n  /**\n   * An object of data in the query string.\n   */\n  query: d.gs(function () {\n    return parseQuery(this.queryString);\n  }, function (value) {\n    this.queryString = stringifyQuery(value);\n  }),\n\n  toJSON: d(function () {\n    return this.href;\n  }),\n\n  toString: d(function () {\n    return this.href;\n  })\n\n});\n\nmodule.exports = Location;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/mergeQuery.js":"\"use strict\";\n\nmodule.exports = require(\"qs/lib/utils\").merge;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/parseQuery.js":"\"use strict\";\n\nmodule.exports = require(\"qs\").parse;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/parseURL.js":"\"use strict\";\n\nvar urlParse = require(\"url\").parse;\n\nfunction parseURL(url) {\n  var parsed = urlParse(url);\n\n  return {\n    protocol: parsed.protocol,\n    auth: parsed.auth,\n    hostname: parsed.hostname,\n    port: parsed.port,\n    pathname: parsed.pathname,\n    search: parsed.search,\n    hash: parsed.hash\n  };\n}\n\nmodule.exports = parseURL;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/Message.js":"\"use strict\";\n\nvar bodec = require(\"bodec\");\nvar d = require(\"describe-property\");\nvar Stream = require(\"bufferedstream\");\nvar bufferStream = require(\"./utils/bufferStream\");\nvar normalizeHeaderName = require(\"./utils/normalizeHeaderName\");\nvar parseCookie = require(\"./utils/parseCookie\");\nvar parseQuery = require(\"./utils/parseQuery\");\n\n/**\n * The default content to use for new messages.\n */\nvar DEFAULT_CONTENT = bodec.fromString(\"\");\n\n/**\n * The default maximum length (in bytes) to use in Message#parseContent.\n */\nvar DEFAULT_MAX_CONTENT_LENGTH = Math.pow(2, 20); // 1M\n\nvar HEADERS_LINE_SEPARATOR = /\\r?\\n/;\nvar HEADER_SEPARATOR = \": \";\n\nfunction defaultParser(message, maxLength) {\n  return message.stringifyContent(maxLength);\n}\n\n/**\n * An HTTP message.\n */\nfunction Message(content, headers) {\n  this.headers = headers;\n  this.content = content;\n}\n\nObject.defineProperties(Message, {\n\n  PARSERS: d({\n    enumerable: true,\n    value: {\n      \"application/json\": function (message, maxLength) {\n        return message.stringifyContent(maxLength).then(JSON.parse);\n      },\n      \"application/x-www-form-urlencoded\": function (message, maxLength) {\n        return message.stringifyContent(maxLength).then(parseQuery);\n      }\n    }\n  })\n\n});\n\nObject.defineProperties(Message.prototype, {\n\n  /**\n   * The headers of this message as { headerName, value }.\n   */\n  headers: d.gs(function () {\n    return this._headers;\n  }, function (value) {\n    this._headers = {};\n\n    if (typeof value === \"string\") {\n      value.split(HEADERS_LINE_SEPARATOR).forEach(function (line) {\n        var index = line.indexOf(HEADER_SEPARATOR);\n\n        if (index === -1) {\n          this.addHeader(line, true);\n        } else {\n          this.addHeader(line.substring(0, index), line.substring(index + HEADER_SEPARATOR.length));\n        }\n      }, this);\n    } else if (value != null) {\n      for (var headerName in value) if (value.hasOwnProperty(headerName)) this.addHeader(headerName, value[headerName]);\n    }\n  }),\n\n  /**\n   * Returns the value of the header with the given name.\n   */\n  getHeader: d(function (headerName) {\n    return this.headers[normalizeHeaderName(headerName)];\n  }),\n\n  /**\n   * Sets the value of the header with the given name.\n   */\n  setHeader: d(function (headerName, value) {\n    this.headers[normalizeHeaderName(headerName)] = value;\n  }),\n\n  /**\n   * Adds the value to the header with the given name.\n   */\n  addHeader: d(function (headerName, value) {\n    headerName = normalizeHeaderName(headerName);\n\n    var headers = this.headers;\n    if (headerName in headers) {\n      if (Array.isArray(headers[headerName])) {\n        headers[headerName].push(value);\n      } else {\n        headers[headerName] = [headers[headerName], value];\n      }\n    } else {\n      headers[headerName] = value;\n    }\n  }),\n\n  /**\n   * An object containing cookies in this message, keyed by name.\n   */\n  cookies: d.gs(function () {\n    if (!this._cookies) {\n      var header = this.headers.Cookie;\n\n      if (header) {\n        var cookies = parseCookie(header);\n\n        // From RFC 2109:\n        // If multiple cookies satisfy the criteria above, they are ordered in\n        // the Cookie header such that those with more specific Path attributes\n        // precede those with less specific. Ordering with respect to other\n        // attributes (e.g., Domain) is unspecified.\n        for (var cookieName in cookies) if (Array.isArray(cookies[cookieName])) cookies[cookieName] = cookies[cookieName][0] || \"\";\n\n        this._cookies = cookies;\n      } else {\n        this._cookies = {};\n      }\n    }\n\n    return this._cookies;\n  }),\n\n  /**\n   * Gets/sets the value of the Content-Type header.\n   */\n  contentType: d.gs(function () {\n    return this.headers[\"Content-Type\"];\n  }, function (value) {\n    this.headers[\"Content-Type\"] = value;\n  }),\n\n  /**\n   * The media type (type/subtype) portion of the Content-Type header without any\n   * media type parameters. e.g. when Content-Type is \"text/plain;charset=utf-8\",\n   * the mediaType is \"text/plain\".\n   *\n   * See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7\n   */\n  mediaType: d.gs(function () {\n    var contentType = this.contentType,\n        match;\n    return contentType && (match = contentType.match(/^([^;,]+)/)) ? match[1].toLowerCase() : null;\n  }, function (value) {\n    this.contentType = value + (this.charset ? \";charset=\" + this.charset : \"\");\n  }),\n\n  /**\n   * Returns the character set used to encode the content of this message. e.g.\n   * when Content-Type is \"text/plain;charset=utf-8\", charset is \"utf-8\".\n   *\n   * See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.4\n   */\n  charset: d.gs(function () {\n    var contentType = this.contentType,\n        match;\n    return contentType && (match = contentType.match(/\\bcharset=([\\w-]+)/)) ? match[1] : null;\n  }, function (value) {\n    this.contentType = this.mediaType + (value ? \";charset=\" + value : \"\");\n  }),\n\n  /**\n   * The content of this message as a binary stream.\n   */\n  content: d.gs(function () {\n    return this._content;\n  }, function (value) {\n    if (value == null) value = DEFAULT_CONTENT;\n\n    if (value instanceof Stream) {\n      this._content = value;\n      value.pause();\n    } else {\n      this._content = new Stream(value);\n    }\n\n    delete this._bufferedContent;\n  }),\n\n  /**\n   * True if the content of this message is buffered, false otherwise.\n   */\n  isBuffered: d.gs(function () {\n    return this._bufferedContent != null;\n  }),\n\n  /**\n   * Returns a binary representation of the content of this message up to\n   * the given length. This is useful in applications that need to access the\n   * entire message body at once, instead of as a stream.\n   *\n   * Note: 0 is a valid value for maxLength. It means \"no limit\".\n   */\n  bufferContent: d(function (maxLength) {\n    if (this._bufferedContent == null) this._bufferedContent = bufferStream(this.content, maxLength);\n\n    return this._bufferedContent;\n  }),\n\n  /**\n   * Returns the content of this message up to the given length as a string\n   * with the given encoding.\n   *\n   * Note: 0 is a valid value for maxLength. It means \"no limit\".\n   */\n  stringifyContent: d(function (maxLength, encoding) {\n    encoding = encoding || this.charset;\n\n    return this.bufferContent(maxLength).then(function (chunk) {\n      return bodec.toString(chunk, encoding);\n    });\n  }),\n\n  /**\n   * Returns a promise for an object of data contained in the content body.\n   *\n   * The maxLength argument specifies the maximum length (in bytes) that the\n   * parser will accept. If the content stream exceeds the maximum length, the\n   * promise is rejected with a MaxLengthExceededError. The appropriate response\n   * to send to the client in this case is 413 Request Entity Too Large, but\n   * many HTTP clients including most web browsers may not understand it.\n   *\n   * Note: 0 is a valid value for maxLength. It means \"no limit\".\n   */\n  parseContent: d(function (maxLength) {\n    if (this._parsedContent) return this._parsedContent;\n\n    if (typeof maxLength !== \"number\") maxLength = DEFAULT_MAX_CONTENT_LENGTH;\n\n    var parser = Message.PARSERS[this.mediaType] || defaultParser;\n    this._parsedContent = parser(this, maxLength);\n\n    return this._parsedContent;\n  })\n\n});\n\nmodule.exports = Message;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/bufferStream.js":"\"use strict\";\n\nvar bodec = require(\"bodec\");\nvar Promise = require(\"./Promise\");\nvar MaxLengthExceededError = require(\"./MaxLengthExceededError\");\n\n/**\n * Returns a promise for a buffer of all content in the given stream up to\n * the given maximum length.\n */\nfunction bufferStream(stream, maxLength) {\n  maxLength = maxLength || Infinity;\n\n  if (!stream.readable) throw new Error(\"Cannot buffer stream that is not readable\");\n\n  return new Promise(function (resolve, reject) {\n    var chunks = [];\n    var length = 0;\n\n    stream.on(\"error\", reject);\n\n    stream.on(\"data\", function (chunk) {\n      length += chunk.length;\n\n      if (length > maxLength) {\n        reject(new MaxLengthExceededError(maxLength));\n      } else {\n        chunks.push(chunk);\n      }\n    });\n\n    stream.on(\"end\", function () {\n      resolve(bodec.join(chunks));\n    });\n\n    if (typeof stream.resume === \"function\") stream.resume();\n  });\n}\n\nmodule.exports = bufferStream;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/MaxLengthExceededError.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\n\n/**\n * An error indicating that some maximum length has been exceeded.\n */\nfunction MaxLengthExceededError(maxLength) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = \"Maximum length exceeded\";\n  this.maxLength = maxLength;\n}\n\nMaxLengthExceededError.prototype = Object.create(Error.prototype, {\n\n  constructor: d(MaxLengthExceededError)\n\n});\n\nmodule.exports = MaxLengthExceededError;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/normalizeHeaderName.js":"\"use strict\";\n\nvar IrregularHeaderNames = require(\"./IrregularHeaderNames\");\n\n/**\n * Normalizes HTTP header names according to RFC 2616.\n */\nfunction normalizeHeaderName(headerName) {\n  headerName = headerName.toLowerCase();\n\n  if (headerName in IrregularHeaderNames) {\n    return IrregularHeaderNames[headerName];\n  }return headerName.replace(/(^|-)([a-z])/g, function (match, dash, letter) {\n    return dash + letter.toUpperCase();\n  });\n}\n\nmodule.exports = normalizeHeaderName;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/IrregularHeaderNames.js":"\"use strict\";\n\n/**\n * A map of HTTP header names with irregular case.\n */\nmodule.exports = [\"Content-ID\", \"Content-MD5\", \"DNT\", \"ETag\", \"P3P\", \"TE\", \"WWW-Authenticate\", \"X-ATT-DeviceId\", \"X-UA-Compatible\", \"X-WebKit-CSP\", \"X-XSS-Protection\"].reduce(function (map, headerName) {\n  map[headerName.toLowerCase()] = headerName;\n  return map;\n}, {});","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/parseCookie.js":"\"use strict\";\n\nvar parseQuery = require(\"./parseQuery\");\n\nfunction parseCookie(cookie) {\n  return parseQuery(cookie, { delimiter: /[;,] */ });\n}\n\nmodule.exports = parseCookie;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/Header.js":"\"use strict\";\n\nvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar normalizeHeaderName = require(\"./utils/normalizeHeaderName\");\n\nvar Header = (function () {\n  function Header(name, value) {\n    _classCallCheck(this, Header);\n\n    this.name = name;\n    this.value = value;\n  }\n\n  _prototypeProperties(Header, null, {\n    name: {\n      get: function () {\n        return this._name;\n      },\n      set: function (value) {\n        this._name = normalizeHeaderName(value);\n      },\n      configurable: true\n    },\n    toString: {\n      value: function toString() {\n        return this.name + \": \" + this.value;\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return Header;\n})();\n\nmodule.exports = Header;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/default.js":"\"use strict\";\n\n/**\n * The default extension for node.js environments.\n */\nmodule.exports = function (mach) {\n  mach.extend(require(\"./accept\"), require(\"./acceptCharset\"), require(\"./acceptEncoding\"), require(\"./acceptLanguage\"), require(\"./client\"), require(\"./middleware\"), require(\"./multipart\"), require(\"./proxy\"), require(\"./server\"), require(\"./statusText\"));\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/accept.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar Accept = require(\"../headers/Accept\");\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given media type.\n     */\n    accepts: d(function (mediaType) {\n      return this.request.accepts(mediaType);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given media type.\n     */\n    accepts: d(function (mediaType) {\n      if (!this._acceptHeader) this._acceptHeader = new Accept(this.headers.Accept);\n\n      return this._acceptHeader.accepts(mediaType);\n    })\n\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/headers/Accept.js":"\"use strict\";\n\nvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar parseMediaValue = require(\"../utils/parseMediaValue\");\nvar parseMediaValues = require(\"../utils/parseMediaValues\");\nvar qualityFactorForMediaValue = require(\"../utils/qualityFactorForMediaValue\");\nvar stringifyMediaValues = require(\"../utils/stringifyMediaValues\");\nvar stringifyMediaValueWithoutQualityFactor = require(\"../utils/stringifyMediaValueWithoutQualityFactor\");\nvar Header = require(\"../Header\");\n\nfunction paramsMatchIgnoringQualityFactor(params, givenParams) {\n  for (var paramName in params) if (params.hasOwnProperty(paramName) && paramName !== \"q\" && givenParams[paramName] !== params[paramName]) {\n    return false;\n  }return true;\n}\n\nfunction byHighestPrecedence(a, b) {\n  //   Accept: text/*, text/html, text/html;level=1, */*\n  //\n  // have the following precedence:\n  //\n  //   1) text/html;level=1\n  //   2) text/html\n  //   3) text/*\n  //   4) */*\n  return stringifyMediaValueWithoutQualityFactor(b).length - stringifyMediaValueWithoutQualityFactor(a).length;\n}\n\n/**\n * Represents an HTTP Accept header and provides several methods for\n * determining acceptable media types.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1\n */\n\nvar Accept = (function (Header) {\n  function Accept(value) {\n    _classCallCheck(this, Accept);\n\n    _get(Object.getPrototypeOf(Accept.prototype), \"constructor\", this).call(this, \"Accept\", value);\n  }\n\n  _inherits(Accept, Header);\n\n  _prototypeProperties(Accept, null, {\n    value: {\n\n      /**\n       * Returns the value of this header as a string.\n       */\n\n      get: function () {\n        return stringifyMediaValues(this._mediaValues) || \"*/*\";\n      },\n      set: function (value) {\n        this._mediaValues = value ? parseMediaValues(value) : [];\n      },\n      configurable: true\n    },\n    accepts: {\n\n      /**\n       * Returns true if the given media type is acceptable.\n       */\n\n      value: function accepts(mediaType) {\n        return this.qualityFactorForMediaType(mediaType) !== 0;\n      },\n      writable: true,\n      configurable: true\n    },\n    qualityFactorForMediaType: {\n\n      /**\n       * Returns the quality factor for the given media type.\n       */\n\n      value: function qualityFactorForMediaType(mediaType) {\n        var values = this._mediaValues;\n\n        if (!values.length) {\n          return 1;\n        }var givenValue = parseMediaValue(mediaType);\n        var matchingValues = values.filter(function (value) {\n          return (value.type === \"*\" || value.type === givenValue.type) && (value.subtype === \"*\" || value.subtype === givenValue.subtype) && paramsMatchIgnoringQualityFactor(value.params, givenValue.params);\n        }).sort(byHighestPrecedence);\n\n        if (!matchingValues.length) {\n          return 0;\n        }return qualityFactorForMediaValue(matchingValues[0]);\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return Accept;\n})(Header);\n\nmodule.exports = Accept;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/parseMediaValue.js":"\"use strict\";\n\n/**\n * Parses a media value string including parameters and returns an object\n * containing the type, subtype, and an object of parameters.\n *\n *   parseMediaValue(\"text/html;level=2;q=0.4\") =>\n *     { type: 'text',\n *       subtype: 'html', \n *       params: { level: '2', q: '0.4' } }\n *\n *   parseMediaValue(\"en-gb;q=0.8\", \"-\") =>\n *     { type: 'en',\n *       subtype: 'gb',\n *       params: { q: '0.8' } }\n *\n *   parseMediaValue(\"unicode-1-1;q=0.8\") =>\n *     { type: 'unicode-1-1',\n *       subtype: undefined,\n *       params: { q: '0.8' } }\n */\nfunction parseMediaValue(value, typeSeparator) {\n  typeSeparator = typeSeparator || \"/\";\n\n  var parts = value.split(/\\s*;\\s*/);\n  var mediaTypes = parts.shift().split(typeSeparator, 2);\n  var params = parts.reduce(function (memo, part) {\n    var nameValue = part.split(\"=\", 2);\n    memo[nameValue[0]] = nameValue[1];\n    return memo;\n  }, {});\n\n  return {\n    type: mediaTypes[0],\n    subtype: mediaTypes[1],\n    params: params\n  };\n}\n\nmodule.exports = parseMediaValue;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/parseMediaValues.js":"\"use strict\";\n\nvar parseMediaValue = require(\"./parseMediaValue\");\n\n/**\n * Parses a string containing multiple media values and returns an array\n * of objects containing data about each value. Such strings are used as\n * the values of the Accept* family of HTTP headers.\n */\nfunction parseMediaValues(value, typeSeparator) {\n  return value.split(/\\s*,\\s*/).map(function (mediaValue) {\n    return parseMediaValue(mediaValue, typeSeparator);\n  });\n}\n\nmodule.exports = parseMediaValues;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/qualityFactorForMediaValue.js":"\"use strict\";\n\n/**\n * Returns the quality factor for the given media value object.\n */\nfunction qualityFactorForMediaValue(value) {\n  var qualityFactor = value.params && value.params.q;\n  return qualityFactor ? parseFloat(qualityFactor) : 1;\n}\n\nmodule.exports = qualityFactorForMediaValue;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/stringifyMediaValues.js":"\"use strict\";\n\nvar stringifyMediaValue = require(\"./stringifyMediaValue\");\n\n/**\n * Creates a string from objects containing media values. Such a string may\n * be used as the value of the Accept* family of HTTP headers.\n */\nfunction stringifyMediaValues(values, typeSeparator) {\n  return values.map(function (mediaValue) {\n    return stringifyMediaValue(mediaValue, typeSeparator);\n  }).join(\", \");\n}\n\nmodule.exports = stringifyMediaValues;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/stringifyMediaValue.js":"\"use strict\";\n\n/**\n * Creates a string from an object containing a media value. This object may\n * have properties containing the type, subtype, and parameters.\n *\n *   stringifyMediaValue({ type: 'text', subtype: 'html', params: { level: '2', q: '0.4' } }) =>\n *     \"text/html;level=2;q=0.4\"\n *\n *   stringifyMediaValue({ type: 'en', subtype: 'gb', params: { q: '0.8' } }, \"-\") =>\n *     \"en-gb;q=0.8\"\n *\n *   stringifyMediaValue({ type: 'unicode-1-1', params: { q: '0.8' } }) =>\n *     \"unicode-1-1;q=0.8\"\n */\nfunction stringifyMediaValue(value, typeSeparator) {\n  typeSeparator = typeSeparator || \"/\";\n\n  var string = value.type || \"*\";\n\n  if (value.subtype) string += typeSeparator + value.subtype;\n\n  if (value.params) {\n    var params = value.params;\n\n    for (var paramName in params) {\n      if (params.hasOwnProperty(paramName)) {\n        string += \";\" + paramName;\n\n        if (params[paramName] != null) string += \"=\" + params[paramName];\n      }\n    }\n  }\n\n  return string;\n}\n\nmodule.exports = stringifyMediaValue;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/stringifyMediaValueWithoutQualityFactor.js":"\"use strict\";\n\nvar stringifyMediaValue = require(\"./stringifyMediaValue\");\n\nfunction cloneParamsWithoutQualityFactor(params) {\n  var clone = {};\n\n  for (var paramName in params) if (params.hasOwnProperty(paramName) && paramName !== \"q\") clone[paramName] = params[paramName];\n\n  return clone;\n}\n\n/**\n * Creates a string from an object containing a media value,\n * ignoring any \"q\" value parameters.\n */\nfunction stringifyMediaValueWithoutQualityFactor(value, typeSeparator) {\n  return stringifyMediaValue({\n    type: value.type,\n    subtype: value.subtype,\n    params: value.params && cloneParamsWithoutQualityFactor(value.params)\n  }, typeSeparator);\n}\n\nmodule.exports = stringifyMediaValueWithoutQualityFactor;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/acceptCharset.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar AcceptCharset = require(\"../headers/AcceptCharset\");\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given character set.\n     */\n    acceptsCharset: d(function (charset) {\n      return this.request.acceptsCharset(charset);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given character set.\n     */\n    acceptsCharset: d(function (charset) {\n      if (!this._acceptCharsetHeader) this._acceptCharsetHeader = new AcceptCharset(this.headers[\"Accept-Charset\"]);\n\n      return this._acceptCharsetHeader.accepts(charset);\n    })\n\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/headers/AcceptCharset.js":"\"use strict\";\n\nvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar parseMediaValue = require(\"../utils/parseMediaValue\");\nvar parseMediaValues = require(\"../utils/parseMediaValues\");\nvar qualityFactorForMediaValue = require(\"../utils/qualityFactorForMediaValue\");\nvar stringifyMediaValues = require(\"../utils/stringifyMediaValues\");\nvar Header = require(\"../Header\");\n\nfunction byHighestPrecedence(a, b) {\n  // \"*\" gets least precedence, all others are equal\n  return a === \"*\" ? -1 : b === \"*\" ? 1 : 0;\n}\n\n/**\n * Represents an HTTP Accept-Charset header and provides several methods\n * for determining acceptable content character sets.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2\n */\n\nvar AcceptCharset = (function (Header) {\n  function AcceptCharset(value) {\n    _classCallCheck(this, AcceptCharset);\n\n    _get(Object.getPrototypeOf(AcceptCharset.prototype), \"constructor\", this).call(this, \"Accept-Charset\", value);\n  }\n\n  _inherits(AcceptCharset, Header);\n\n  _prototypeProperties(AcceptCharset, null, {\n    value: {\n\n      /**\n       * Returns the value of this header as a string.\n       */\n\n      get: function () {\n        return stringifyMediaValues(this._mediaValues) || \"\";\n      },\n      set: function (value) {\n        this._mediaValues = value ? parseMediaValues(value) : [];\n      },\n      configurable: true\n    },\n    accepts: {\n\n      /**\n       * Returns true if the given charset is acceptable.\n       */\n\n      value: function accepts(charset) {\n        return this.qualityFactorForCharset(charset) !== 0;\n      },\n      writable: true,\n      configurable: true\n    },\n    qualityFactorForCharset: {\n\n      /**\n       * Returns the quality factor for the given charset.\n       */\n\n      value: function qualityFactorForCharset(charset) {\n        var values = this._mediaValues;\n\n        var givenValue = parseMediaValue(charset);\n        var matchingValues = values.filter(function (value) {\n          if (value.type === \"*\") return true;\n\n          return value.type === givenValue.type;\n        }).sort(byHighestPrecedence);\n\n        // From RFC 2616:\n        // The special value \"*\", if present in the Accept-Charset field, matches every character\n        // set (including ISO-8859-1) which is not mentioned elsewhere in the Accept-Charset field.\n        // If no \"*\" is present in an Accept-Charset field, then all character sets not explicitly\n        // mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of\n        // 1 if not explicitly mentioned.\n        if (givenValue.type === \"iso-8859-1\") {\n          if (matchingValues.length && matchingValues[0].type === \"iso-8859-1\") {\n            return qualityFactorForMediaValue(matchingValues[0]);\n          }return 1;\n        }\n\n        if (!matchingValues.length) {\n          return 0;\n        }return qualityFactorForMediaValue(matchingValues[0]);\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return AcceptCharset;\n})(Header);\n\nmodule.exports = AcceptCharset;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/acceptEncoding.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar AcceptEncoding = require(\"../headers/AcceptEncoding\");\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given content encoding.\n     */\n    acceptsEncoding: d(function (encoding) {\n      return this.request.acceptsEncoding(encoding);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given content encoding.\n     */\n    acceptsEncoding: d(function (encoding) {\n      if (!this._acceptEncodingHeader) this._acceptEncodingHeader = new AcceptEncoding(this.headers[\"Accept-Encoding\"]);\n\n      return this._acceptEncodingHeader.accepts(encoding);\n    })\n\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/headers/AcceptEncoding.js":"\"use strict\";\n\nvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar parseMediaValue = require(\"../utils/parseMediaValue\");\nvar parseMediaValues = require(\"../utils/parseMediaValues\");\nvar qualityFactorForMediaValue = require(\"../utils/qualityFactorForMediaValue\");\nvar stringifyMediaValues = require(\"../utils/stringifyMediaValues\");\nvar Header = require(\"../Header\");\n\nfunction byHighestPrecedence(a, b) {\n  // \"*\" gets least precedence, all others are equal\n  return a === \"*\" ? -1 : b === \"*\" ? 1 : 0;\n}\n\n/**\n * Represents an HTTP Accept-Encoding header and provides several methods\n * for determining acceptable content encodings.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n */\n\nvar AcceptEncoding = (function (Header) {\n  function AcceptEncoding(value) {\n    _classCallCheck(this, AcceptEncoding);\n\n    _get(Object.getPrototypeOf(AcceptEncoding.prototype), \"constructor\", this).call(this, \"Accept-Encoding\", value);\n  }\n\n  _inherits(AcceptEncoding, Header);\n\n  _prototypeProperties(AcceptEncoding, null, {\n    value: {\n\n      /**\n       * Returns the value of this header as a string.\n       */\n\n      get: function () {\n        return stringifyMediaValues(this._mediaValues) || \"\";\n      },\n      set: function (value) {\n        this._mediaValues = value ? parseMediaValues(value) : [];\n      },\n      configurable: true\n    },\n    accepts: {\n\n      /**\n       * Returns true if the given encoding is acceptable.\n       */\n\n      value: function accepts(encoding) {\n        return this.qualityFactorForEncoding(encoding) !== 0;\n      },\n      writable: true,\n      configurable: true\n    },\n    qualityFactorForEncoding: {\n\n      /**\n       * Returns the quality factor for the given encoding.\n       */\n\n      value: function qualityFactorForEncoding(encoding) {\n        var values = this._mediaValues;\n\n        var givenValue = parseMediaValue(encoding);\n        var matchingValues = values.filter(function (value) {\n          if (value.type === \"*\") return true;\n\n          return value.type === givenValue.type;\n        }).sort(byHighestPrecedence);\n\n        // From RFC 2616:\n        // The \"identity\" content-coding is always acceptable, unless\n        // specifically refused because the Accept-Encoding field includes\n        // \"identity;q=0\", or because the field includes \"*;q=0\" and does\n        // not explicitly include the \"identity\" content-coding. If the\n        // Accept-Encoding field-value is empty, then only the \"identity\"\n        // encoding is acceptable.\n        if (givenValue.type === \"identity\") {\n          if (matchingValues.length && matchingValues[0].type === \"identity\") {\n            return qualityFactorForMediaValue(matchingValues[0]);\n          }return 1;\n        }\n\n        if (!matchingValues.length) {\n          return 0;\n        }return qualityFactorForMediaValue(matchingValues[0]);\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return AcceptEncoding;\n})(Header);\n\nmodule.exports = AcceptEncoding;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/acceptLanguage.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar AcceptLanguage = require(\"../headers/AcceptLanguage\");\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given content language.\n     */\n    acceptsLanguage: d(function (language) {\n      return this.request.acceptsLanguage(language);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given content language.\n     */\n    acceptsLanguage: d(function (language) {\n      if (!this._acceptLanguageHeader) this._acceptLanguageHeader = new AcceptLanguage(this.headers[\"Accept-Language\"]);\n\n      return this._acceptLanguageHeader.accepts(language);\n    })\n\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/headers/AcceptLanguage.js":"\"use strict\";\n\nvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar parseMediaValue = require(\"../utils/parseMediaValue\");\nvar parseMediaValues = require(\"../utils/parseMediaValues\");\nvar qualityFactorForMediaValue = require(\"../utils/qualityFactorForMediaValue\");\nvar stringifyMediaValues = require(\"../utils/stringifyMediaValues\");\nvar stringifyMediaValueWithoutQualityFactor = require(\"../utils/stringifyMediaValueWithoutQualityFactor\");\nvar Header = require(\"../Header\");\n\nfunction byHighestPrecedence(a, b) {\n  // \"*\" gets least precedence, all others are compared by specificity\n  return a === \"*\" ? -1 : b === \"*\" ? 1 : byMostSpecific(a, b);\n}\n\nfunction byMostSpecific(a, b) {\n  return stringifyMediaValueWithoutQualityFactor(b).length - stringifyMediaValueWithoutQualityFactor(a).length;\n}\n\n/**\n * Represents an HTTP Accept-Language header and provides several methods\n * for determining acceptable content languages.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n */\n\nvar AcceptLanguage = (function (Header) {\n  function AcceptLanguage(value) {\n    _classCallCheck(this, AcceptLanguage);\n\n    _get(Object.getPrototypeOf(AcceptLanguage.prototype), \"constructor\", this).call(this, \"Accept-Language\", value);\n  }\n\n  _inherits(AcceptLanguage, Header);\n\n  _prototypeProperties(AcceptLanguage, null, {\n    value: {\n\n      /**\n       * Returns the value of this header as a string.\n       */\n\n      get: function () {\n        return stringifyMediaValues(this._mediaValues, \"-\") || \"\";\n      },\n      set: function (value) {\n        this._mediaValues = value ? parseMediaValues(value, \"-\") : [];\n      },\n      configurable: true\n    },\n    accepts: {\n\n      /**\n       * Returns true if the given language is acceptable.\n       */\n\n      value: function accepts(language) {\n        return this.qualityFactorForLanguage(language) !== 0;\n      },\n      writable: true,\n      configurable: true\n    },\n    qualityFactorForLanguage: {\n\n      /**\n       * Returns the quality factor for the given language.\n       */\n\n      value: function qualityFactorForLanguage(language) {\n        var values = this._mediaValues;\n\n        if (!values.length) {\n          return 1;\n        }var givenValue = parseMediaValue(language, \"-\");\n        var matchingValues = values.filter(function (value) {\n          if (value.type === \"*\") return true;\n\n          if (value.subtype && value.subtype !== givenValue.subtype) return false;\n\n          return value.type === givenValue.type;\n        }).sort(byHighestPrecedence);\n\n        if (!matchingValues.length) {\n          return 0;\n        }return qualityFactorForMediaValue(matchingValues[0]);\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return AcceptLanguage;\n})(Header);\n\nmodule.exports = AcceptLanguage;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/client.js":"\"use strict\";\n\nvar objectAssign = require(\"object-assign\");\nvar sendRequest = require(\"../utils/sendRequest\");\nvar Location = require(\"../Location\");\n\nfunction defaultApp(conn) {\n  return sendRequest(conn, conn.location);\n}\n\nmodule.exports = function (mach) {\n  mach.call = require(\"../utils/callApp\");\n\n  [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"TRACE\"].forEach(function (method) {\n    var property = method.toLowerCase();\n\n    mach[property] = function (app, options, modifier) {\n      if (typeof app !== \"function\") {\n        modifier = options;\n\n        if (typeof app === \"string\") {\n          // get(url, modifier)\n          options = { url: app };\n        } else if (app instanceof Location) {\n          // get(location, modifier)\n          options = { location: app };\n        } else {\n          // get(options, modifier)\n          options = objectAssign({}, app || {});\n        }\n\n        app = defaultApp;\n      } else if (typeof options === \"string\") {\n        // get(app, url, modifier)\n        options = { url: options };\n      } else if (options instanceof Location) {\n        // get(app, location, modifier)\n        options = { location: options };\n      } else if (typeof options !== \"object\") {\n        // get(app, modifier)\n        modifier = options;\n        options = {};\n      } else {\n        // get(app, options, modifier)\n        options = objectAssign({}, options || {});\n      }\n\n      options.method = method;\n\n      return mach.call(app, options, modifier);\n    };\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/sendRequest.js":"\"use strict\";\n\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar AbortablePromise = require(\"./AbortablePromise\");\n\nfunction sendRequest(conn, location) {\n  var transport = location.protocol === \"https:\" ? https : http;\n\n  return new AbortablePromise(function (resolve, reject, onAbort) {\n    var nodeRequest = transport.request({\n      method: conn.method,\n      protocol: location.protocol,\n      auth: location.auth,\n      hostname: location.hostname,\n      port: location.port,\n      path: location.path,\n      headers: conn.request.headers\n    });\n\n    nodeRequest.on(\"response\", function (nodeResponse) {\n      conn.status = nodeResponse.statusCode;\n      conn.response.headers = nodeResponse.headers;\n      conn.response.content = nodeResponse;\n      resolve(conn);\n    });\n\n    nodeRequest.on(\"error\", reject);\n\n    onAbort(function () {\n      nodeRequest.abort();\n      resolve();\n    });\n\n    conn.request.content.pipe(nodeRequest);\n  });\n}\n\nmodule.exports = sendRequest;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/AbortablePromise.js":"\"use strict\";\n\nvar Promise = require(\"./Promise\");\n\nfunction makeAbortable(promise, abort) {\n  promise.abort = abort;\n\n  // Hijack promise.then so it returns an abortable promise.\n  var _then = promise.then;\n  promise.then = function () {\n    return makeAbortable(_then.apply(promise, arguments), abort);\n  };\n\n  return promise;\n}\n\n/**\n * A Promise class with an abort() method that calls the onAbort function\n * provided by the resolver.\n *\n * Example:\n *\n *   var promise = new AbortablePromise(function (resolve, reject, onAbort) {\n *     // Use resolve & reject as you normally would.\n *     var request = makeRequest( ... , function (error, response) {\n *       if (error) {\n *         reject(error);\n *       } else {\n *         resolve(response);\n *       }\n *     });\n *   \n *     // Use onAbort to register a promise.abort() function. It is the\n *     // responsibility of this function to abort the execution of the\n *     // promise and resolve/reject as needed.\n *     onAbort(function () {\n *       request.abort();\n *       reject(new Error('Request was aborted'));\n *     });\n *   });\n *\n *   promise.abort(); // Calls the onAbort handler.\n */\nfunction AbortablePromise(resolver) {\n  if (typeof resolver !== \"function\") throw new Error(\"AbortablePromise needs a resolver function\");\n\n  var abort;\n  var promise = new Promise(function (resolve, reject) {\n    var aborter;\n\n    abort = function () {\n      if (aborter == null) return;\n\n      var fn = aborter;\n      aborter = null;\n\n      try {\n        return fn.apply(this, arguments);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    resolver(function (child) {\n      if (child && typeof child.abort === \"function\") {\n        aborter = child.abort;\n      } else {\n        aborter = null;\n      }\n\n      resolve.apply(this, arguments);\n    }, function () {\n      aborter = null;\n      reject.apply(this, arguments);\n    }, function (fn) {\n      if (typeof fn !== \"function\") throw new Error(\"onAbort needs a function\");\n\n      aborter = fn;\n    });\n  });\n\n  return makeAbortable(promise, abort);\n}\n\nmodule.exports = AbortablePromise;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/middleware.js":"\"use strict\";\n\nvar middleware = require(\"../middleware\");\n\nmodule.exports = function (mach) {\n  for (var property in middleware) if (middleware.hasOwnProperty(property)) mach[property] = middleware[property];\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/index.js":"\"use strict\";\n\nmodule.exports = {\n  basicAuth: require(\"./basicAuth\"),\n  \"catch\": require(\"./catch\"),\n  charset: require(\"./charset\"),\n  contentType: require(\"./contentType\"),\n  favicon: require(\"./favicon\"),\n  file: require(\"./file\"),\n  gzip: require(\"./gzip\"),\n  logger: require(\"./logger\"),\n  mapper: require(\"./mapper\"),\n  methodOverride: require(\"./methodOverride\"),\n  modified: require(\"./modified\"),\n  params: require(\"./params\"),\n  proxy: require(\"./proxy\"),\n  rewrite: require(\"./rewrite\"),\n  router: require(\"./router\"),\n  session: require(\"./session\"),\n  stack: require(\"./stack\"),\n  token: require(\"./token\")\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/basicAuth.js":"\"use strict\";\n\nvar mach = require(\"../index\");\nvar Promise = require(\"../utils/Promise\");\n\nmach.extend(require(\"../extensions/server\"));\n\n/**\n * A middleware that performs basic auth on the incoming request before passing\n * it downstream.\n *\n * The `validate` argument must be a function that accepts two arguments: the\n * username and password given in the request. It must return the username to\n * use for the request (or simply `true` to indicate the given username is\n * valid) or a promise for such a value. The validated username is stored in the\n * `remoteUser` request variable.\n *\n * When authorization fails, the client automatically receives a 401 Unauthorized\n * response with the appropriate challenge in the WWW-Authenticate header.\n *\n * Example:\n *\n *   mach.basicAuth(app, function (user, pass) {\n *     // Return a boolean value to indicate the given credentials are valid.\n *     return (user === 'admin' && pass === 'secret');\n *   });\n *\n *   mach.basicAuth(app, function (user, pass) {\n *     // Return a promise for the actual username to use.\n *     return query('SELECT username FROM users WHERE handle=? AND password=?', user, pass);\n *   });\n */\nfunction basicAuth(app, options) {\n  options = options || {};\n\n  if (typeof options === \"function\") options = { validate: options };\n\n  if (typeof options.validate !== \"function\") throw new Error(\"mach.basicAuth needs a validation function\");\n\n  var realm = options.realm || \"Authorization Required\";\n\n  return function (conn) {\n    if (conn.remoteUser) return conn.call(app); // Don't overwrite existing remoteUser.\n\n    var credentials = conn.auth.split(\":\", 2);\n    var username = credentials[0],\n        password = credentials[1];\n\n    return Promise.resolve(options.validate(username, password)).then(function (user) {\n      if (user) {\n        conn.remoteUser = user === true ? username : user;\n        return conn.call(app);\n      }\n\n      conn.response.headers[\"WWW-Authenticate\"] = \"Basic realm=\\\"\" + realm + \"\\\"\";\n      conn.text(401, \"Not Authorized\");\n    });\n  };\n}\n\nmodule.exports = basicAuth;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/server.js":"\"use strict\";\n\nvar fs = require(\"fs\");\nvar d = require(\"describe-property\");\nvar objectAssign = require(\"object-assign\");\nvar getMimeType = require(\"../utils/getMimeType\");\nvar filterProperties = require(\"../utils/filterProperties\");\nvar stringifyCookie = require(\"../utils/stringifyCookie\");\nvar saveToDisk = require(\"../utils/saveToDisk\");\n\nmodule.exports = function (mach) {\n  mach.bind = require(\"../utils/bindApp\");\n  mach.createConnection = require(\"../utils/createConnection\");\n  mach.serve = require(\"../utils/serveApp\");\n\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * True if the request uses XMLHttpRequest, false otherwise.\n     */\n    isXHR: d.gs(function () {\n      return this.request.headers[\"X-Requested-With\"] === \"XMLHttpRequest\";\n    }),\n\n    /**\n     * A high-level method that returns a promise for an object that is the\n     * union of parameters contained in the request body and query string.\n     *\n     * The paramTypes argument may be used to filter parameters. It functions\n     * like a whitelist of acceptable parameters and increases the security of\n     * your app by not returning any parameters that you do not specify.\n     *\n     *   // This function parses a list of comma-separated values in\n     *   // a request parameter into an array.\n     *   function parseList(value) {\n     *     return value.split(',');\n     *   }\n     *\n     *   function app(conn) {\n     *     return conn.getParams({\n     *       name: String,\n     *       age: Number,\n     *       hobbies: parseList\n     *     }).then(function (params) {\n     *       // params.name will be a string, params.age a number, and\n     *       // params.hobbies an array if they were provided in the\n     *       // request. params won't contain any other properties.\n     *     });\n     *   }\n     *\n     * Of course, paramTypes may be omitted entirely to get a hash of all parameters.\n     * \n     * The maxLength argument is passed directly to the request's parseContent method.\n     *\n     *   var maxUploadLimit = Math.pow(2, 20); // 1 mb\n     *\n     *   function app(conn) {\n     *     return conn.getParams(maxUploadLimit).then(function (params) {\n     *       // params is the union of query and request content params\n     *     });\n     *   }\n     *\n     * Note: Content parameters take precedence over query parameters with the same name.\n     */\n    getParams: d(function (paramTypes, maxLength) {\n      if (typeof paramTypes !== \"object\") {\n        maxLength = paramTypes;\n        paramTypes = null;\n      }\n\n      var request = this.request;\n      var queryParams = objectAssign({}, this.query);\n\n      return request.parseContent(maxLength).then(function (contentParams) {\n        // Content params take precedence over query params.\n        var params = objectAssign(queryParams, contentParams);\n        return paramTypes ? filterProperties(params, paramTypes) : params;\n      });\n    }),\n\n    /**\n     * Redirects the client to the given location. If status is not\n     * given, it defaults to 302 Found.\n     */\n    redirect: d(function (status, location) {\n      if (typeof status !== \"number\") {\n        location = status;\n        status = 302;\n      }\n\n      this.status = status;\n      this.response.headers.Location = location;\n    }),\n\n    /**\n     * Redirects the client back to the URL they just came from, or\n     * to the given location if it isn't known.\n     */\n    back: d(function (location) {\n      this.redirect(this.request.headers.Referer || location || \"/\");\n    }),\n\n    /**\n     * A quick way to write the status and/or content to the response.\n     *\n     * Examples:\n     *\n     *   conn.send(404);\n     *   conn.send(404, 'Not Found');\n     *   conn.send('Hello world');\n     *   conn.send(fs.createReadStream('welcome.txt'));\n     */\n    send: d(function (status, content) {\n      if (typeof status === \"number\") {\n        this.status = status;\n      } else {\n        content = status;\n      }\n\n      if (content != null) this.response.content = content;\n    }),\n\n    /**\n     * Sends the given text in a text/plain response.\n     */\n    text: d(function (status, text) {\n      this.response.contentType = \"text/plain\";\n      this.send(status, text);\n    }),\n\n    /**\n     * Sends the given HTML in a text/html response.\n     */\n    html: d(function (status, html) {\n      this.response.contentType = \"text/html\";\n      this.send(status, html);\n    }),\n\n    /**\n     * Sends the given JSON in an application/json response.\n     */\n    json: d(function (status, json) {\n      this.response.contentType = \"application/json\";\n\n      if (typeof status === \"number\") {\n        this.status = status;\n      } else {\n        json = status;\n      }\n\n      if (json != null) this.response.content = typeof json === \"string\" ? json : JSON.stringify(json);\n    }),\n\n    /**\n     * Sends a file to the client with the given options. The following\n     * options are available:\n     *\n     * - content/path   The raw file content as a string, Buffer, stream, or\n     *                  path to a file on disk\n     * - type           The Content-Type of the file. Defaults to a guess based\n     *                  on the file extension when a file path is given\n     * - length/size    The Content-Length of the file, if it's known. Defaults\n     *                  to the size of the file when a file path is given\n     *\n     * Examples:\n     *\n     *   response.file('path/to/file.txt');\n     *   response.file(200, 'path/to/file.txt');\n     */\n    file: d(function (status, options) {\n      if (typeof status === \"number\") {\n        this.status = status;\n      } else {\n        options = status;\n      }\n\n      var response = this.response;\n\n      if (typeof options === \"string\") options = { path: options };\n\n      if (options.content) {\n        response.content = options.content;\n      } else if (typeof options.path === \"string\") {\n        response.content = fs.createReadStream(options.path);\n      } else {\n        throw new Error(\"Missing file content/path\");\n      }\n\n      if (options.type || options.path) response.headers[\"Content-Type\"] = options.type || getMimeType(options.path);\n\n      if (options.length || options.size) {\n        response.headers[\"Content-Length\"] = options.length || options.size;\n      } else if (typeof options.path === \"string\") {\n        response.headers[\"Content-Length\"] = fs.statSync(options.path).size;\n      }\n    })\n\n  });\n\n  mach.extend(require(\"./multipart\"));\n\n  var _handlePart = mach.Message.prototype.handlePart;\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Sets a cookie with the given name and options.\n     */\n    setCookie: d(function (name, options) {\n      this.addHeader(\"Set-Cookie\", stringifyCookie(name, options));\n    }),\n\n    /**\n     * Override the multipart extension's Message#handlePart to enable\n     * streaming file uploads to disk when parsing multipart messages.\n     */\n    handlePart: d(function (part) {\n      return part.filename ? saveToDisk(part, \"MachUpload-\") : _handlePart.apply(this, arguments);\n    })\n\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/getMimeType.js":"\"use strict\";\n\nvar MimeTypes = require(\"../MimeTypes\");\nvar ExtTypes = {};\n\nObject.keys(MimeTypes).forEach(function (type) {\n  MimeTypes[type].forEach(function (ext) {\n    ExtTypes[ext] = type;\n  });\n});\n\nvar DEFAULT_TYPE = \"application/octet-stream\";\nvar EXT_MATCHER = /\\.(\\w+)$/;\n\nfunction getMimeType(file, defaultType) {\n  var match = file.match(EXT_MATCHER);\n  return match && ExtTypes[match[1]] || defaultType || DEFAULT_TYPE;\n}\n\nmodule.exports = getMimeType;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/MimeTypes.js":"\"use strict\";\n\n/**\n * A map of MIME types to file extensions that correspond to that type.\n */\nmodule.exports = {\n  \"text/html\": [\"html\", \"htm\", \"shtml\"],\n  \"text/css\": [\"css\"],\n  \"text/xml\": [\"xml\"],\n  \"image/gif\": [\"gif\"],\n  \"image/jpeg\": [\"jpeg\", \"jpg\"],\n  \"application/javascript\": [\"js\"],\n  \"application/atom+xml\": [\"atom\"],\n  \"application/rss+xml\": [\"rss\"],\n\n  \"text/mathml\": [\"mml\"],\n  \"text/plain\": [\"txt\"],\n  \"text/vnd.sun.j2me.app-descriptor\": [\"jad\"],\n  \"text/vnd.wap.wml\": [\"wml\"],\n  \"text/x-component\": [\"htc\"],\n\n  \"image/png\": [\"png\"],\n  \"image/tiff\": [\"tif\", \"tiff\"],\n  \"image/vnd.wap.wbmp\": [\"wbmp\"],\n  \"image/x-icon\": [\"ico\"],\n  \"image/x-jng\": [\"jng\"],\n  \"image/x-ms-bmp\": [\"bmp\"],\n  \"image/svg+xml\": [\"svg\", \"svgz\"],\n  \"image/webp\": [\"webp\"],\n\n  \"application/font-woff\": [\"woff\"],\n  \"application/java-archive\": [\"jar\", \"war\", \"ear\"],\n  \"application/json\": [\"json\"],\n  \"application/mac-binhex40\": [\"hqx\"],\n  \"application/msword\": [\"doc\"],\n  \"application/pdf\": [\"pdf\"],\n  \"application/postscript\": [\"ps\", \"eps\", \"ai\"],\n  \"application/rtf\": [\"rtf\"],\n  \"application/vnd.apple.mpegurl\": [\"m3u8\"],\n  \"application/vnd.ms-excel\": [\"xls\"],\n  \"application/vnd.ms-fontobject\": [\"eot\"],\n  \"application/vnd.ms-powerpoint\": [\"ppt\"],\n  \"application/vnd.wap.wmlc\": [\"wmlc\"],\n  \"application/vnd.google-earth.kml+xml\": [\"kml\"],\n  \"application/vnd.google-earth.kmz\": [\"kmz\"],\n  \"application/x-7z-compressed\": [\"7z\"],\n  \"application/x-cocoa\": [\"cco\"],\n  \"application/x-java-archive-diff\": [\"jardiff\"],\n  \"application/x-java-jnlp-file\": [\"jnlp\"],\n  \"application/x-makeself\": [\"run\"],\n  \"application/x-perl\": [\"pl\", \"pm\"],\n  \"application/x-pilot\": [\"prc\", \"pdb\"],\n  \"application/x-rar-compressed\": [\"rar\"],\n  \"application/x-redhat-package-manager\": [\"rpm\"],\n  \"application/x-sea\": [\"sea\"],\n  \"application/x-shockwave-flash\": [\"swf\"],\n  \"application/x-stuffit\": [\"sit\"],\n  \"application/x-tcl\": [\"tcl\", \"tk\"],\n  \"application/x-x509-ca-cert\": [\"der\", \"pem\", \"crt\"],\n  \"application/x-xpinstall\": [\"xpi\"],\n  \"application/xhtml+xml\": [\"xhtml\"],\n  \"application/xspf+xml\": [\"xspf\"],\n  \"application/zip\": [\"zip\"],\n\n  \"application/octet-stream\": [\"bin\", \"exe\", \"dll\", \"deb\", \"dmg\", \"iso\", \"img\", \"msi\", \"msp\", \"msm\"],\n\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\": [\"docx\"],\n  \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": [\"xlsx\"],\n  \"application/vnd.openxmlformats-officedocument.presentationml.presentation\": [\"pptx\"],\n\n  \"audio/midi\": [\"mid\", \"midi\", \"kar\"],\n  \"audio/mpeg\": [\"mp3\"],\n  \"audio/ogg\": [\"ogg\"],\n  \"audio/x-m4a\": [\"m4a\"],\n  \"audio/x-realaudio\": [\"ra\"],\n\n  \"video/3gpp\": [\"3gpp\", \"3gp\"],\n  \"video/mp2t\": [\"ts\"],\n  \"video/mp4\": [\"mp4\"],\n  \"video/mpeg\": [\"mpeg\", \"mpg\"],\n  \"video/quicktime\": [\"mov\"],\n  \"video/webm\": [\"webm\"],\n  \"video/x-flv\": [\"flv\"],\n  \"video/x-m4v\": [\"m4v\"],\n  \"video/x-mng\": [\"mng\"],\n  \"video/x-ms-asf\": [\"asx\", \"asf\"],\n  \"video/x-ms-wmv\": [\"wmv\"],\n  \"video/x-msvideo\": [\"avi\"]\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/filterProperties.js":"\"use strict\";\n\n/**\n * Returns a shallow copy of the properties of the given object,\n * filtered by the functions in propertyTypes.\n */\nfunction filterProperties(object, propertyTypes) {\n  var properties = {};\n\n  var type, value;\n  for (var property in object) {\n    type = propertyTypes[property];\n\n    if (typeof type === \"function\" && object.hasOwnProperty(property)) {\n      value = type(object[property]);\n\n      if (value !== undefined) properties[property] = value;\n    }\n  }\n\n  return properties;\n}\n\nmodule.exports = filterProperties;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/stringifyCookie.js":"\"use strict\";\n\n/**\n * Creates a cookie string using the given options, which may be any of\n * the following:\n *\n * - value\n * - domain\n * - path\n * - expires\n * - secure\n * - httpOnly or HttpOnly\n */\nfunction stringifyCookie(name, options) {\n  options = options || {};\n\n  if (typeof options === \"string\") options = { value: options };\n\n  var cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(options.value || \"\");\n\n  if (options.domain) cookie += \"; domain=\" + options.domain;\n\n  if (options.path) cookie += \"; path=\" + options.path;\n\n  if (options.expires) cookie += \"; expires=\" + (options.expires instanceof Date) ? options.expires.toUTCString() : options.expires;\n\n  if (options.secure) cookie += \"; secure\";\n\n  if (options.httpOnly || options.HttpOnly) cookie += \"; HttpOnly\";\n\n  return cookie;\n}\n\nmodule.exports = stringifyCookie;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/saveToDisk.js":"\"use strict\";\n\nvar fs = require(\"fs\");\nvar File = require(\"./File\");\nvar Promise = require(\"./Promise\");\nvar makeTemporaryPath = require(\"./makeTemporaryPath\");\n\nfunction saveToDisk(message, filePrefix) {\n  return new Promise(function (resolve, reject) {\n    var content = message.content;\n    var path = makeTemporaryPath(filePrefix);\n    var stream = fs.createWriteStream(path);\n    var size = 0;\n\n    content.on(\"error\", reject);\n\n    content.on(\"data\", function (chunk) {\n      size += chunk.length;\n      stream.write(chunk);\n    });\n\n    content.on(\"end\", function () {\n      stream.end(function () {\n        resolve(new File({\n          path: path,\n          name: message.filename,\n          type: message.mediaType,\n          size: size\n        }));\n      });\n    });\n\n    if (typeof content.resume === \"function\") content.resume();\n  });\n}\n\nmodule.exports = saveToDisk;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/File.js":"\"use strict\";\n\nfunction File(properties) {\n  this.path = properties.path;\n  this.name = properties.name;\n  this.type = properties.type;\n  this.size = properties.size;\n}\n\nmodule.exports = File;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/makeTemporaryPath.js":"\"use strict\";\n\nvar path = require(\"path\");\nvar TMP_DIR = require(\"os\").tmpDir();\n\nfunction makeTemporaryPath(prefix) {\n  prefix = prefix || \"\";\n\n  var random = (Math.random() * 4294967296 + 1).toString(36);\n  var now = new Date();\n  var date = \"\" + now.getYear() + now.getMonth() + now.getDate();\n  var name = [prefix, date, \"-\", process.pid, \"-\", random].join(\"\");\n\n  return path.join(TMP_DIR, name);\n}\n\nmodule.exports = makeTemporaryPath;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/bindApp.js":"\"use strict\";\n\nvar createRequestHandler = require(\"./createRequestHandler\");\n\n/**\n * Binds the given app to the \"request\" event of the given node HTTP server\n * so that it is called whenever the server receives a new request. Returns\n * the request handler function.\n */\nfunction bindApp(app, nodeServer) {\n  var requestHandler = createRequestHandler(app);\n  nodeServer.on(\"request\", requestHandler);\n  return requestHandler;\n}\n\nmodule.exports = bindApp;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/createRequestHandler.js":"\"use strict\";\n\n/* jshint -W058 */\nvar createConnection = require(\"./createConnection\");\n\n/**\n * HTTP status codes that don't have entities.\n */\nvar STATUS_WITHOUT_CONTENT = {\n  100: true,\n  101: true,\n  204: true,\n  304: true\n};\n\n/**\n * Binds the given app to the \"request\" event of the given node HTTP server\n * so that it is called whenever the server receives a new request.\n *\n * Returns the request handler function.\n */\nfunction createRequestHandler(app) {\n  return function (nodeRequest, nodeResponse) {\n    var conn = createConnection(nodeRequest);\n\n    conn.call(app).then(function () {\n      var isHead = conn.method === \"HEAD\";\n      var isEmpty = isHead || STATUS_WITHOUT_CONTENT[conn.status] === true;\n      var headers = conn.response.headers;\n      var content = conn.response.content;\n\n      if (isEmpty && !isHead) headers[\"Content-Length\"] = 0;\n\n      if (!headers.Date) headers.Date = new Date().toUTCString();\n\n      nodeResponse.writeHead(conn.status, headers);\n\n      if (isEmpty) {\n        nodeResponse.end();\n\n        if (typeof content.destroy === \"function\") content.destroy();\n      } else {\n        content.pipe(nodeResponse);\n      }\n    }, function (error) {\n      conn.onError(error);\n      nodeResponse.writeHead(500, { \"Content-Type\": \"text/plain\" });\n      nodeResponse.end(\"Internal Server Error\");\n    });\n  };\n}\n\nmodule.exports = createRequestHandler;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/createConnection.js":"\"use strict\";\n\nvar Connection = require(\"../Connection\");\nvar Location = require(\"../Location\");\n\n/**\n * Standard ports for HTTP protocols.\n */\nvar STANDARD_PORTS = {\n  \"http:\": \"80\",\n  \"https:\": \"443\"\n};\n\nfunction ensureTrailingColon(string) {\n  return string[string.length - 1] === \":\" ? string : string + \":\";\n}\n\n/**\n * Creates a new Location object that is reverse-proxy aware.\n */\nfunction createLocation(nodeRequest) {\n  var headers = nodeRequest.headers;\n\n  var protocol;\n  if (process.env.HTTPS === \"on\" || headers[\"x-forwarded-ssl\"] === \"on\" || headers[\"font-end-https\"] === \"on\") {\n    protocol = \"https:\";\n  } else if (headers[\"x-url-scheme\"]) {\n    protocol = ensureTrailingColon(headers[\"x-url-scheme\"]);\n  } else if (headers[\"x-forwarded-protocol\"]) {\n    protocol = ensureTrailingColon(headers[\"x-forwarded-protocol\"].split(\",\")[0]);\n  } else if (headers[\"x-forwarded-proto\"]) {\n    protocol = ensureTrailingColon(headers[\"x-forwarded-proto\"].split(\",\")[0]);\n  } else {\n    protocol = \"http:\";\n  }\n\n  var host;\n  if (headers[\"x-forwarded-host\"]) {\n    var hosts = headers[\"x-forwarded-host\"].split(/,\\s?/);\n    host = hosts[hosts.length - 1];\n  } else if (headers.host) {\n    host = headers.host;\n  } else if (process.env.SERVER_NAME) {\n    host = process.env.SERVER_NAME;\n  }\n\n  var hostParts = host.split(\":\", 2);\n  var hostname = hostParts[0];\n  var port = hostParts[1] || headers[\"x-forwarded-port\"];\n\n  if (port == null) {\n    if (headers[\"x-forwarded-host\"]) {\n      port = STANDARD_PORTS[protocol];\n    } else if (headers[\"x-forwarded-proto\"]) {\n      port = STANDARD_PORTS[headers[\"x-forwarded-proto\"].split(\",\")[0]];\n    }\n  }\n\n  var path = nodeRequest.url;\n\n  return new Location({\n    protocol: protocol,\n    hostname: hostname,\n    port: port,\n    path: path\n  });\n}\n\n/**\n * Creates a mach.Connection from the given node.js HTTP request and\n * server (optional) objects. This is a low-level method that is not\n * generally needed by application-level code.\n */\nfunction createConnection(nodeRequest) {\n  var conn = new Connection({\n    version: nodeRequest.httpVersion,\n    method: nodeRequest.method,\n    location: createLocation(nodeRequest),\n    headers: nodeRequest.headers,\n    content: nodeRequest,\n    remoteHost: nodeRequest.connection.remoteAddress,\n    remotePort: nodeRequest.connection.remotePort\n  });\n\n  nodeRequest.on(\"close\", function () {\n    conn.onClose();\n  });\n\n  return conn;\n}\n\nmodule.exports = createConnection;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/serveApp.js":"\"use strict\";\n\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar bindApp = require(\"./bindApp\");\n\n/**\n * The default port that node servers bind to.\n */\nvar DEFAULT_PORT = 5000;\n\n/**\n * Creates and starts a node HTTP server that serves the given app.\n *\n * Options may be any of the following:\n *\n * - host     The host name to accept connections on. Defaults to INADDR_ANY\n * - port     The port to listen on. Defaults to 5000\n * - socket   Unix socket file to listen on (trumps host/port)\n * - quiet    Set true to prevent the server from writing startup/shutdown\n *            messages to the console. Defaults to false\n * - timeout  The timeout to use when gracefully shutting down servers when\n *            SIGINT or SIGTERM are received. If a server doesn't close within\n *            this time (probably because it has open persistent connections)\n *            it is forecefully stopped when the process exits. Defaults to 100,\n *            meaning that servers forcefully shutdown after 100ms\n * - key      Private key to use for SSL (HTTPS only)\n * - cert     Public X509 certificate to use (HTTPS only)\n *\n * Note: When setting the timeout, be careful not to exceed any hard timeouts\n * specified by your PaaS. For example, Heroku's dyno manager will not permit\n * a timeout longer than ten seconds. See\n * https://devcenter.heroku.com/articles/dynos#graceful-shutdown-with-sigterm\n *\n * Returns the node HTTP server instance.\n */\nfunction serveApp(app, options) {\n  options = options || {};\n\n  if (typeof options === \"number\") {\n    options = { port: options };\n  } else if (typeof options === \"string\") {\n    options = { socket: options };\n  }\n\n  var nodeServer;\n  if (options.key && options.cert) {\n    nodeServer = https.createServer({ key: options.key, cert: options.cert });\n  } else {\n    nodeServer = http.createServer();\n  }\n\n  function shutdown() {\n    if (!options.quiet) console.log(\">> Shutting down...\");\n\n    // Force the process to exit if the server doesn't\n    // close all connections within the given timeout.\n    var timer = setTimeout(function () {\n      if (!options.quiet) console.log(\">> Exiting\");\n\n      process.exit(0);\n    }, options.timeout || 100);\n\n    // Don't let this timer keep the event loop running.\n    timer.unref();\n\n    nodeServer.close();\n  }\n\n  nodeServer.once(\"listening\", function () {\n    bindApp(app, nodeServer);\n\n    process.once(\"SIGINT\", shutdown);\n    process.once(\"SIGTERM\", shutdown);\n\n    if (!options.quiet) {\n      var address = nodeServer.address();\n      var message = \">> mach web server started on node \" + process.versions.node + \"\\n\";\n\n      if (typeof address === \"string\") {\n        message += \">> Listening on \" + address;\n      } else {\n        message += \">> Listening on \" + address.address;\n\n        if (address.port) message += \":\" + address.port;\n      }\n\n      message += \", use CTRL+C to stop\";\n\n      console.log(message);\n    }\n  });\n\n  if (options.socket) {\n    nodeServer.listen(options.socket);\n  } else {\n    nodeServer.listen(options.port || DEFAULT_PORT, options.host);\n  }\n\n  return nodeServer;\n}\n\nmodule.exports = serveApp;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/multipart.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar parseContent = require(\"../multipart/parseContent\");\n\nvar BOUNDARY_MATCHER = /^multipart\\/.*boundary=(?:\"([^\"]+)\"|([^;]+))/im;\nvar NAME_MATCHER = /\\bname=\"([^\"]+)\"/i;\n\nmodule.exports = function (mach) {\n  mach.Message.PARSERS[\"multipart/form-data\"] = function (message, maxLength) {\n    function partHandler(part) {\n      return message.handlePart(part);\n    }\n\n    // If the content has been buffered, use the buffer.\n    if (message.isBuffered) {\n      return message.bufferContent().then(function (content) {\n        return parseContent(content, message.multipartBoundary, maxLength, partHandler);\n      });\n    }\n\n    return parseContent(message.content, message.multipartBoundary, maxLength, partHandler);\n  };\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * The value that was used as the boundary for multipart content. This\n     * is present only in multipart messages.\n     */\n    multipartBoundary: d.gs(function () {\n      var contentType = this.contentType,\n          match;\n      return contentType && (match = contentType.match(BOUNDARY_MATCHER)) ? match[1] || match[2] : null;\n    }),\n\n    /**\n     * The unique \"name\" or ID of this message, as given in its Content-Disposition\n     * header. This is usually present only on messages that are part of a larger,\n     * multipart message.\n     */\n    name: d.gs(function () {\n      var contentDisposition = this.headers[\"Content-Disposition\"],\n          match;\n      return contentDisposition && (match = contentDisposition.match(NAME_MATCHER)) ? match[1] : this.headers[\"Content-ID\"];\n    }),\n\n    /**\n     * The filename of this message, as given in its Content-Disposition header.\n     * This is usually present only on messages that are part of a larger, multipart\n     * message and that originate from a file upload.\n     */\n    filename: d.gs(function () {\n      var contentDisposition = this.headers[\"Content-Disposition\"];\n\n      if (contentDisposition) {\n        // Match quoted filenames.\n        var match = contentDisposition.match(/filename=\"([^;]*)\"/i);\n\n        var filename;\n        if (match) {\n          filename = decodeURIComponent(match[1].replace(/\\\\\"/g, \"\\\"\"));\n        } else {\n          // Match unquoted filenames.\n          match = contentDisposition.match(/filename=([^;]+)/i);\n\n          if (match) filename = decodeURIComponent(match[1]);\n        }\n\n        if (filename) {\n          // Take the last part of the filename. This handles full Windows\n          // paths given by IE (and possibly other dumb clients).\n          return filename.substr(filename.lastIndexOf(\"\\\\\") + 1);\n        }\n      }\n\n      return null;\n    }),\n\n    /**\n     * A low-level hook responsible for handling Message objects embedded as multipart\n     * objects inside this message. It should return the value to use for the given\n     * message in the parameters hash. By default parts that originate from file uploads\n     * are buffered and all others are converted to strings.\n     *\n     * This should be overridden if you want to specify some kind of custom handling\n     * for multipart data, such as streaming it directly to a network file storage.\n     * For example, the server extension overrides this method to save uploaded files\n     * to a temporary location on disk.\n     */\n    handlePart: d(function (part) {\n      return part.filename ? part.bufferContent() : part.stringifyContent();\n    })\n\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/multipart/parseContent.js":"\"use strict\";\n\nvar Stream = require(\"bufferedstream\");\nvar MaxLengthExceededError = require(\"../utils/MaxLengthExceededError\");\nvar resolveProperties = require(\"../utils/resolveProperties\");\nvar Promise = require(\"../utils/Promise\");\nvar Parser = require(\"./Parser\");\n\nfunction defaultPartHandler(part) {\n  return part.parseContent();\n}\n\n/**\n * Parses a multipart message and returns a promise for an object of\n * the parts it contains, keyed by the name of that part. The partHandler\n * argument is a function that should be used to resolve the value of\n * a part. It defaults to collecting all the content in a buffer.\n */\nfunction parseContent(content, boundary, maxLength, partHandler) {\n  if (typeof maxLength === \"function\") {\n    partHandler = maxLength;\n    maxLength = null;\n  }\n\n  partHandler = partHandler || defaultPartHandler;\n  maxLength = maxLength || Infinity;\n\n  return new Promise(function (resolve, reject) {\n    if (!(content instanceof Stream)) content = new Stream(content);\n\n    var parts = {};\n    var contentLength = 0;\n\n    var parser = new Parser(boundary, function (part) {\n      parts[part.name] = partHandler(part);\n    });\n\n    content.on(\"error\", reject);\n\n    content.on(\"data\", function (chunk) {\n      var length = chunk.length;\n      contentLength += length;\n\n      if (maxLength && contentLength > maxLength) {\n        reject(new MaxLengthExceededError(maxLength));\n      } else {\n        var parsedLength = parser.execute(chunk);\n\n        if (parsedLength !== length) reject(new Error(\"Error parsing multipart body: \" + parsedLength + \" of \" + length + \" bytes parsed\"));\n      }\n    });\n\n    content.on(\"end\", function () {\n      try {\n        parser.finish();\n        resolve(resolveProperties(parts));\n      } catch (error) {\n        reject(new Error(\"Error parsing multipart body: \" + error.message));\n      }\n    });\n\n    content.resume();\n  });\n}\n\nmodule.exports = parseContent;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/resolveProperties.js":"\"use strict\";\n\nvar Promise = require(\"./Promise\");\n\nfunction resolveProperties(object) {\n  var keys = Object.keys(object);\n\n  return Promise.all(keys.map(function (key) {\n    return object[key];\n  })).then(function (values) {\n    keys.forEach(function (key, index) {\n      object[key] = values[index];\n    });\n\n    return object;\n  });\n}\n\nmodule.exports = resolveProperties;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/multipart/Parser.js":"\"use strict\";\n\n/* jshint -W058 */\nvar bodec = require(\"bodec\");\nvar Stream = require(\"bufferedstream\");\nvar Message = require(\"../Message\");\n\n// This parser is modified from the one in the node-formidable\n// project, written by Felix Geisendrfer. MIT licensed.\n\nvar s = 0;\nvar S = {\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++\n};\n\nvar f = 1;\nvar F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\n\nvar LF = 10;\nvar CR = 13;\nvar SPACE = 32;\nvar HYPHEN = 45;\nvar COLON = 58;\n\nfunction Parser(boundary, partHandler) {\n  this.boundary = bodec.fromRaw(\"\\r\\n--\" + boundary);\n  this.lookBehind = bodec.create(this.boundary.length + 8);\n  this.boundaryChars = {};\n\n  var i = this.boundary.length;\n  while (i) this.boundaryChars[this.boundary[--i]] = true;\n\n  this.state = S.START;\n  this.index = null;\n  this.flags = 0;\n\n  if (typeof partHandler !== \"function\") throw new Error(\"multipart.Parser needs a part handler\");\n\n  this.onPart = partHandler;\n}\n\nParser.prototype.execute = function (chunk) {\n  var chunkLength = chunk.length,\n      prevIndex = this.index,\n      index = this.index,\n      state = this.state,\n      flags = this.flags,\n      lookBehind = this.lookBehind,\n      boundary = this.boundary,\n      boundaryChars = this.boundaryChars,\n      boundaryLength = boundary.length,\n      boundaryEnd = boundaryLength - 1,\n      c,\n      cl;\n\n  for (var i = 0; i < chunkLength; ++i) {\n    c = chunk[i];\n\n    switch (state) {\n      case S.START:\n        index = 0;\n        state = S.START_BOUNDARY;\n      /* falls through */\n      case S.START_BOUNDARY:\n        if (index == boundaryLength - 2) {\n          if (c != CR) {\n            return i;\n          }\n          index++;\n          break;\n        } else if (index == boundaryLength - 1) {\n          if (c != LF) {\n            return i;\n          }\n          index = 0;\n          this._callback(\"partBegin\");\n          state = S.HEADER_FIELD_START;\n          break;\n        }\n\n        if (c != boundary[index + 2]) {\n          return i;\n        }\n        index++;\n        break;\n      case S.HEADER_FIELD_START:\n        state = S.HEADER_FIELD;\n        this._mark(\"headerName\", i);\n        index = 0;\n      /* falls through */\n      case S.HEADER_FIELD:\n        if (c == CR) {\n          this._clear(\"headerName\");\n          state = S.HEADERS_ALMOST_DONE;\n          break;\n        }\n\n        index++;\n        if (c == HYPHEN) {\n          break;\n        }\n\n        if (c == COLON) {\n          if (index == 1) {\n            // empty header field\n            return i;\n          }\n          this._dataCallback(\"headerName\", chunk, true, i);\n          state = S.HEADER_VALUE_START;\n          break;\n        }\n\n        cl = c | 32; // lower-case\n        if (cl < 97 || cl > 122) {\n          // not between \"a\" and \"z\"\n          return i;\n        }\n        break;\n      case S.HEADER_VALUE_START:\n        if (c == SPACE) {\n          break;\n        }\n        this._mark(\"headerValue\", i);\n        state = S.HEADER_VALUE;\n      /* falls through */\n      case S.HEADER_VALUE:\n        if (c == CR) {\n          this._dataCallback(\"headerValue\", chunk, true, i);\n          this._callback(\"headerEnd\");\n          state = S.HEADER_VALUE_ALMOST_DONE;\n        }\n        break;\n      case S.HEADER_VALUE_ALMOST_DONE:\n        if (c != LF) {\n          return i;\n        }\n        state = S.HEADER_FIELD_START;\n        break;\n      case S.HEADERS_ALMOST_DONE:\n        if (c != LF) {\n          return i;\n        }\n        this._callback(\"headersEnd\");\n        state = S.PART_DATA_START;\n        break;\n      case S.PART_DATA_START:\n        state = S.PART_DATA;\n        this._mark(\"partData\", i);\n      /* falls through */\n      case S.PART_DATA:\n        prevIndex = index;\n\n        if (index === 0) {\n          // boyer-moore derrived algorithm to safely skip non-boundary data\n          i += boundaryEnd;\n          while (i < chunkLength && !(chunk[i] in boundaryChars)) {\n            i += boundaryLength;\n          }\n          i -= boundaryEnd;\n          c = chunk[i];\n        }\n\n        if (index < boundaryLength) {\n          if (boundary[index] == c) {\n            if (index === 0) {\n              this._dataCallback(\"partData\", chunk, true, i);\n            }\n            index++;\n          } else {\n            index = 0;\n          }\n        } else if (index == boundaryLength) {\n          index++;\n          if (c == CR) {\n            // CR = part boundary\n            flags |= F.PART_BOUNDARY;\n          } else if (c == HYPHEN) {\n            // HYPHEN = end boundary\n            flags |= F.LAST_BOUNDARY;\n          } else {\n            index = 0;\n          }\n        } else if (index - 1 == boundaryLength) {\n          if (flags & F.PART_BOUNDARY) {\n            index = 0;\n            if (c == LF) {\n              // unset the PART_BOUNDARY flag\n              flags &= ~F.PART_BOUNDARY;\n              this._callback(\"partEnd\");\n              this._callback(\"partBegin\");\n              state = S.HEADER_FIELD_START;\n              break;\n            }\n          } else if (flags & F.LAST_BOUNDARY) {\n            if (c == HYPHEN) {\n              this._callback(\"partEnd\");\n              // this._callback('end');\n              state = S.END;\n            } else {\n              index = 0;\n            }\n          } else {\n            index = 0;\n          }\n        }\n\n        if (index > 0) {\n          // when matching a possible boundary, keep a lookBehind\n          // reference in case it turns out to be a false lead\n          lookBehind[index - 1] = c;\n        } else if (prevIndex > 0) {\n          // if our boundary turned out to be rubbish, the captured\n          // lookBehind belongs to partData\n          this._callback(\"partData\", lookBehind, 0, prevIndex);\n          prevIndex = 0;\n          this._mark(\"partData\", i);\n\n          // reconsider the current character even so it interrupted the\n          // sequence it could be the beginning of a new sequence\n          i--;\n        }\n\n        break;\n      case S.END:\n        break;\n      default:\n        return i;\n    }\n  }\n\n  this._dataCallback(\"headerName\", chunk);\n  this._dataCallback(\"headerValue\", chunk);\n  this._dataCallback(\"partData\", chunk);\n\n  this.index = index;\n  this.state = state;\n  this.flags = flags;\n\n  return chunkLength;\n};\n\nParser.prototype.finish = function () {\n  if (this.state !== S.END) throw new Error(\"Stream ended unexpectedly (state: \" + this.state + \")\");\n};\n\nParser.prototype._mark = function (name, i) {\n  this[name + \"Mark\"] = i;\n};\n\nParser.prototype._clear = function (name) {\n  delete this[name + \"Mark\"];\n};\n\nParser.prototype._callback = function (name, chunk, start, end) {\n  if (start !== undefined && start === end) return;\n\n  var prop = \"on\" + name.substr(0, 1).toUpperCase() + name.substr(1);\n\n  if (prop in this) this[prop](chunk, start, end);\n};\n\nParser.prototype._dataCallback = function (name, chunk, clear, i) {\n  var prop = name + \"Mark\";\n\n  if (prop in this) {\n    if (!clear) {\n      this._callback(name, chunk, this[prop], chunk.length);\n      this[prop] = 0;\n    } else {\n      this._callback(name, chunk, this[prop], i);\n      delete this[prop];\n    }\n  }\n};\n\nParser.prototype.onPartBegin = function () {\n  this._stream = new Stream();\n  this._part = new Message(this._stream);\n  this._headerName = \"\";\n  this._headerValue = \"\";\n};\n\nParser.prototype.onHeaderName = function (chunk, start, end) {\n  this._headerName += bodec.toUnicode(chunk, start, end);\n};\n\nParser.prototype.onHeaderValue = function (chunk, start, end) {\n  this._headerValue += bodec.toUnicode(chunk, start, end);\n};\n\nParser.prototype.onHeaderEnd = function () {\n  this._part.setHeader(this._headerName, this._headerValue);\n  this._headerName = \"\";\n  this._headerValue = \"\";\n};\n\nParser.prototype.onHeadersEnd = function () {\n  this.onPart(this._part);\n};\n\nParser.prototype.onPartData = function (chunk, start, end) {\n  this._stream.write(bodec.slice(chunk, start, end));\n};\n\nParser.prototype.onPartEnd = function () {\n  this._stream.end();\n};\n\nmodule.exports = Parser;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/catch.js":"\"use strict\";\n\n/**\n * A middleware that \"catches\" non-Errors that are thrown from the downstream\n * app and returns them instead. This can be useful for breaking out of a\n * nested promise chain, for example.\n *\n * Example:\n *\n *   mach.catch(function (conn) {\n *     throw 200;\n *   });\n */\nfunction catchError(app) {\n  return function (conn) {\n    return conn.call(app).then(undefined, function (reason) {\n      if (reason instanceof Error) throw reason;\n\n      return reason;\n    });\n  };\n}\n\nmodule.exports = catchError;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/charset.js":"\"use strict\";\n\n/**\n * A middleware that sets a default character set in the Content-Type\n * header of the response if none is already specified.\n */\nfunction charset(app, defaultCharset) {\n  defaultCharset = defaultCharset || \"utf-8\";\n\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var response = conn.response;\n\n      if (response.contentType && response.charset == null) response.charset = defaultCharset;\n    });\n  };\n}\n\nmodule.exports = charset;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/contentType.js":"\"use strict\";\n\n/**\n * A middleware that sets a default Content-Type header in case one hasn't\n * already been set in a downstream app.\n */\nfunction contentType(app, defaultType) {\n  defaultType = defaultType || \"text/html\";\n\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var headers = conn.response.headers;\n\n      if (!headers[\"Content-Type\"]) headers[\"Content-Type\"] = defaultType;\n    });\n  };\n}\n\nmodule.exports = contentType;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/favicon.js":"\"use strict\";\n\n/**\n * A middleware that returns the given response to requests for \"/favicon.ico\".\n * Defaults to returning an empty 404.\n */\nfunction favicon(app, response) {\n  response = response || 404;\n\n  return function (conn) {\n    return conn.pathname === \"/favicon.ico\" ? response : conn.call(app);\n  };\n}\n\nmodule.exports = favicon;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/file.js":"\"use strict\";\n\nvar fs = require(\"fs\");\nvar mach = require(\"../index\");\nvar Promise = require(\"../utils/Promise\");\nvar getFileStats = require(\"../utils/getFileStats\");\nvar generateETag = require(\"../utils/generateETag\");\nvar generateIndex = require(\"../utils/generateIndex\");\nvar joinPaths = require(\"../utils/joinPaths\");\n\nmach.extend(require(\"../extensions/server\"));\n\n/**\n * A middleware for serving files efficiently from the file system according\n * to the path specified in the `pathname` variable.\n *\n * Options may be any of the following:\n *\n * - root               The path to the root directory to serve files from\n * - index              An array of file names to try and serve when the\n *                      request targets a directory (e.g. [\"index.html\", \"index.htm\"]).\n *                      May simply be truthy to use [\"index.html\"]\n * - autoIndex          Set this true to automatically generate an index page\n *                      listing a directory's contents when the request targets\n *                      a directory with no index file\n * - useLastModified    Set this true to include the Last-Modified header\n *                      based on the mtime of the file. Defaults to true\n * - useETag            Set this true to include the ETag header based on\n *                      the MD5 checksum of the file. Defaults to false\n *\n * Alternatively, options may be a file path to the root directory.\n *\n * If a matching file cannot be found, the request is forwarded to the\n * downstream app. Otherwise, the file is streamed through to the response.\n *\n * Examples:\n *\n *   // Use the root directory name directly.\n *   app.use(mach.file, '/public');\n *\n *   // Serve static files out of /public, and automatically\n *   // serve an index.htm from any directory that has one.\n *   app.use(mach.file, {\n *     root: '/public',\n *     index: 'index.htm',\n *     useETag: true\n *   });\n *\n *   // Serve static files out of /public, and automatically\n *   // serve an index.html from any directory that has one.\n *   // Also, automatically generate a directory listing for\n *   // any directory without an index.html file.\n *   app.use(mach.file, {\n *     root: '/public',\n *     index: true,\n *     autoIndex: true\n *   });\n *\n * This function may also be used outside of the context of a middleware\n * stack to create a standalone app.\n *\n *   var app = mach.file('/public');\n *   mach.serve(app);\n */\nfunction file(app, options) {\n  // Allow mach.file(path|options)\n  if (typeof app === \"string\" || typeof app === \"object\") {\n    options = app;\n    app = null;\n  }\n\n  options = options || {};\n\n  // Allow mach.file(path) and app.use(mach.file, path)\n  if (typeof options === \"string\") options = { root: options };\n\n  var root = options.root;\n  if (typeof root !== \"string\" || !fs.existsSync(root) || !fs.statSync(root).isDirectory()) throw new Error(\"Invalid root directory: \" + root);\n\n  var index = options.index || [];\n  if (index) {\n    if (typeof index === \"string\") {\n      index = [index];\n    } else if (!Array.isArray(index)) {\n      index = [\"index.html\"];\n    }\n  }\n\n  var useLastModified = \"useLastModified\" in options ? !!options.useLastModified : true;\n  var useETag = !!options.useETag;\n\n  function sendFile(conn, path, stats) {\n    conn.file({\n      path: path,\n      size: stats.size\n    });\n\n    if (useLastModified) conn.response.headers[\"Last-Modified\"] = stats.mtime.toUTCString();\n\n    if (useETag) {\n      return generateETag(path).then(function (etag) {\n        conn.response.headers.ETag = etag;\n      });\n    }\n  }\n\n  return function (conn) {\n    if (conn.method !== \"GET\" && conn.method !== \"HEAD\") return conn.call(app);\n\n    var pathname = conn.pathname;\n\n    // Reject paths that contain \"..\".\n    if (pathname.indexOf(\"..\") !== -1) return conn.text(403, \"Forbidden\");\n\n    var path = joinPaths(root, pathname);\n\n    return getFileStats(path).then(function (stats) {\n      if (stats && stats.isFile()) return sendFile(conn, path, stats);\n\n      if (!stats || !stats.isDirectory()) return conn.call(app);\n\n      // Try to serve one of the index files.\n      var indexPaths = index.map(function (indexPath) {\n        return joinPaths(path, indexPath);\n      });\n\n      return Promise.all(indexPaths.map(getFileStats)).then(function (stats) {\n        for (var i = 0, len = stats.length; i < len; ++i) if (stats[i]) return sendFile(conn, indexPaths[i], stats[i]);\n\n        if (!options.autoIndex) return conn.call(app);\n\n        // Redirect /images => /images/\n        if (!/\\/$/.test(pathname)) return conn.redirect(pathname + \"/\");\n\n        // Automatically generate and serve an index file.\n        return generateIndex(root, pathname, conn.basename).then(function (html) {\n          conn.html(html);\n        });\n      });\n    });\n  };\n}\n\nmodule.exports = file;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/getFileStats.js":"\"use strict\";\n\nvar fs = require(\"fs\");\nvar Promise = require(\"./Promise\");\n\n/**\n * Returns stats for the given file or null if it doesn't exist.\n */\nfunction getFileStats(path) {\n  return new Promise(function (resolve, reject) {\n    fs.stat(path, function (error, stats) {\n      if (error && error.code !== \"ENOENT\") {\n        reject(error);\n      } else {\n        resolve(stats || null);\n      }\n    });\n  });\n}\n\nmodule.exports = getFileStats;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/generateETag.js":"\"use strict\";\n\nvar fs = require(\"fs\");\nvar crypto = require(\"crypto\");\nvar Promise = require(\"./Promise\");\n\nfunction generateETag(path) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(path, function (error, data) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(\"\\\"\" + crypto.createHash(\"md5\").update(data).digest(\"hex\") + \"\\\"\");\n      }\n    });\n  });\n}\n\nmodule.exports = generateETag;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/generateIndex.js":"\"use strict\";\n\nvar fs = require(\"fs\");\nvar Promise = require(\"./Promise\");\nvar getFileStats = require(\"./getFileStats\");\nvar getMimeType = require(\"./getMimeType\");\nvar formatByteSize = require(\"./formatByteSize\");\nvar formatString = require(\"util\").format;\nvar joinPaths = require(\"./joinPaths\");\n\nvar MACH_VERSION = require(\"../version\");\n\nvar PAGE_TEMPLATE = [\"<html>\", \"<head>\", \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\" />\", \"<title>%s</title>\", \"<style type=\\\"text/css\\\">\", \"  body { font: 14px Helvetica, Arial, sans-serif; padding: 0 10px; }\", \"  address { text-align: right; font-style: italic; }\", \"  table { width: 100%; }\", \"  tr.even { background: #f3f3f3; }\", \"  .name { text-align: left; }\", \"  .size, .type, .mtime { text-align: right; }\", \"</style>\", \"</head>\", \"<body>\", \"<h1>%s</h1>\", \"<hr>\", \"<table cellspacing=\\\"0\\\" cellpadding=\\\"3\\\">\", \"<tr>\", \"  <th class=\\\"name\\\">Name</th>\", \"  <th class=\\\"size\\\">Size</th>\", \"  <th class=\\\"type\\\">Type</th>\", \"  <th class=\\\"mtime\\\">Last Modified</th>\", \"</tr>\", \"%s\", \"</table>\", \"<hr>\", \"<address>%s/%s</address>\", \"</body>\", \"</html>\"].join(\"\\n\");\n\nvar ROW_TEMPLATE = [\"<tr class=\\\"%s\\\">\", \"  <td class=\\\"name\\\"><a href=\\\"%s\\\">%s</a></td>\", \"  <td class=\\\"size\\\">%s</td>\", \"  <td class=\\\"type\\\">%s</td>\", \"  <td class=\\\"mtime\\\">%s</td>\", \"</tr>\"].join(\"\\n\");\n\nfunction generateIndex(root, pathname, basename) {\n  return new Promise(function (resolve, reject) {\n    var path = joinPaths(root, pathname);\n\n    fs.readdir(path, function (error, files) {\n      if (error) return reject(error);\n\n      var promises = files.map(function (file) {\n        return getFileStats(joinPaths(path, file));\n      });\n\n      Promise.all(promises).then(function (statsArray) {\n        var rows = formatString(ROW_TEMPLATE, \"\", \"../\", \"Parent Directory\", \"\", \"\", \"\");\n        var className = \"even\";\n\n        statsArray.forEach(function (stats, index) {\n          if (stats == null) return; // Ignore broken symlinks!\n\n          var file = files[index];\n          var url = basename + pathname + file;\n          var mtime = stats.mtime;\n\n          var size, type;\n          if (stats.isDirectory()) {\n            size = \"-\";\n            type = \"directory\";\n            url += \"/\";\n            file += \"/\";\n          } else {\n            size = formatByteSize(stats.size);\n            type = getMimeType(file);\n          }\n\n          rows += \"\\n\" + formatString(ROW_TEMPLATE, className, url, file, size, type, mtime);\n\n          className = className === \"even\" ? \"odd\" : \"even\";\n        });\n\n        var title = \"Index of \" + basename + pathname;\n        var content = formatString(PAGE_TEMPLATE, title, title, rows, \"mach\", MACH_VERSION);\n\n        resolve(content);\n      }, reject);\n    });\n  });\n}\n\nmodule.exports = generateIndex;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/formatByteSize.js":"\"use strict\";\n\nvar SUFFIXES = [\"B\", \"K\", \"M\", \"G\", \"T\"];\n\nfunction formatByteSize(size) {\n  var tier = size > 0 ? Math.floor(Math.log(size) / Math.log(1024)) : 0;\n  var n = size / Math.pow(1024, tier);\n\n  if (tier > 0) n = Math.floor(n * 10) / 10; // Preserve only 1 digit after decimal.\n\n  return String(n) + SUFFIXES[tier];\n}\n\nmodule.exports = formatByteSize;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/joinPaths.js":"\"use strict\";\n\nmodule.exports = require(\"path\").join;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/gzip.js":"\"use strict\";\n\nvar zlib = require(\"zlib\");\nvar mach = require(\"../index\");\n\nmach.extend(require(\"../extensions/acceptEncoding\"));\n\nvar GZIP_MATCHER = /text|javascript|json/i;\n\nfunction shouldGzipContentType(contentType) {\n  if (!contentType || contentType === \"text/event-stream\") {\n    return false;\n  }return GZIP_MATCHER.test(contentType);\n}\n\n/**\n * A middleware that gzip's the response content (see http://www.gzip.org/).\n * Options may be any of node's zlib options (see http://nodejs.org/api/zlib.html).\n */\nfunction gzip(app, options) {\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var response = conn.response;\n      var headers = response.headers;\n\n      if (shouldGzipContentType(headers[\"Content-Type\"]) && conn.acceptsEncoding(\"gzip\")) {\n        response.content = response.content.pipe(zlib.createGzip(options));\n\n        delete headers[\"Content-Length\"];\n        headers[\"Content-Encoding\"] = \"gzip\";\n        headers.Vary = \"Accept-Encoding\";\n      }\n    });\n  };\n}\n\nmodule.exports = gzip;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/logger.js":"\"use strict\";\n\n/* jshint -W058 */\nvar strftime = require(\"strftime\").strftime;\n\nfunction defaultMessageHandler(message) {\n  if (typeof console !== \"undefined\" && console.log) console.log(message);\n}\n\n/**\n * A middleware that writes log entry data about the response to a given stream.\n * Log entries are formatted similarly to Apache httpd's Common Log Format\n * (see http://httpd.apache.org/docs/1.3/logs.html#common).\n */\nfunction logger(app, messageHandler) {\n  messageHandler = messageHandler || defaultMessageHandler;\n\n  return function (conn) {\n    var startTime = Date.now();\n\n    return conn.call(app).then(function () {\n      var elapsedTime = Date.now() - startTime;\n      var contentLength = conn.response.headers[\"Content-Length\"];\n\n      if (contentLength == null) contentLength = \"-\";\n\n      var protocol = conn.protocol || \"http:\";\n      protocol = protocol.substr(0, protocol.length - 1).toUpperCase();\n\n      // 127.0.0.1 - frank [10/Oct/2000 13:55:36] \"GET /apache_pb.gif HTTP/1.0\" 200 2326 0.003\n      messageHandler([conn.remoteHost || \"-\", \"-\", // RFC 1413 identity of the client\n      conn.remoteUser || \"-\", \"[\" + strftime(\"%d/%b/%Y %H:%M:%S\", new Date()) + \"]\", \"\\\"\" + conn.method + \" \" + conn.basename + conn.path + \" \" + protocol + \"/\" + conn.version + \"\\\"\", conn.status, contentLength, elapsedTime / 1000].join(\" \"));\n    });\n  };\n}\n\nmodule.exports = logger;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/mapper.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar escapeRegExp = require(\"../utils/escapeRegExp\");\n\nfunction byMostSpecific(a, b) {\n  return b.path.length - a.path.length || (b.host || \"\").length - (a.host || \"\").length;\n}\n\n/**\n * A middleware that provides host and/or location-based routing. Modifies\n * the `basename` connection variable for all downstream apps such that only\n * the portion relevant for dispatch remains in `pathname`.\n *\n *   app.use(mach.mapper, {\n *\n *     'http://example.com/images': function (conn) {\n *       // The hostname used in the request was example.com, and\n *       // the URL path started with \"/images\". If the request was\n *       // GET /images/avatar.jpg, then conn.pathname is /avatar.jpg\n *     },\n *\n *     '/images': function (conn) {\n *       // The URL path started with \"/images\"\n *     }\n *\n *   });\n *\n * This function may also be used outside of the context of a middleware\n * stack to create a standalone app. You can either provide mappings one\n * at a time:\n *\n *   var app = mach.mapper();\n *\n *   app.map('/images', function (conn) {\n *     // ...\n *   });\n *\n * Or all at once:\n *\n *   var app = mach.mapper({\n *\n *     '/images': function (conn) {\n *       // ...\n *     }\n *\n *   });\n *\n * Note: Dispatch is done in such a way that the longest paths are tried first\n * since they are the most specific.\n */\nfunction createMapper(app, map) {\n  // Allow mach.mapper(map)\n  if (typeof app === \"object\") {\n    map = app;\n    app = null;\n  }\n\n  var mappings = [];\n\n  function mapper(conn) {\n    var hostname = conn.hostname;\n    var pathname = conn.pathname;\n\n    var mapping, match, remainingPath;\n    for (var i = 0, len = mappings.length; i < len; ++i) {\n      mapping = mappings[i];\n\n      // Try to match the hostname.\n      if (mapping.hostname && mapping.hostname !== hostname) continue;\n\n      // Try to match the path.\n      if (!(match = pathname.match(mapping.pattern))) continue;\n\n      // Skip if the remaining path doesn't start with a \"/\".\n      remainingPath = match[1];\n      if (remainingPath.length > 0 && remainingPath[0] !== \"/\") continue;\n\n      conn.basename += mapping.path;\n\n      return conn.call(mapping.app);\n    }\n\n    return conn.call(app);\n  }\n\n  Object.defineProperties(mapper, {\n\n    /**\n     * Adds a new mapping that runs the given app when the location used in the\n     * request matches the given location.\n     */\n    map: d(function (location, app) {\n      var hostname, path;\n\n      // If the location is a fully qualified URL use the host as well.\n      var match = location.match(/^https?:\\/\\/(.*?)(\\/.*)/);\n      if (match) {\n        hostname = match[1].replace(/:\\d+$/, \"\"); // Strip the port.\n        path = match[2];\n      } else {\n        path = location;\n      }\n\n      if (path.charAt(0) !== \"/\") throw new Error(\"Mapping path must start with \\\"/\\\", was \\\"\" + path + \"\\\"\");\n\n      path = path.replace(/\\/$/, \"\");\n\n      var pattern = new RegExp(\"^\" + escapeRegExp(path).replace(/\\/+/g, \"/+\") + \"(.*)\");\n\n      mappings.push({\n        hostname: hostname,\n        path: path,\n        pattern: pattern,\n        app: app\n      });\n\n      mappings.sort(byMostSpecific);\n    }),\n\n    /**\n     * Sets the given app as the default for this mapper.\n     */\n    run: d(function (downstreamApp) {\n      app = downstreamApp;\n    })\n\n  });\n\n  // Allow app.use(mach.mapper, map)\n  if (typeof map === \"object\") for (var location in map) if (map.hasOwnProperty(location)) mapper.map(location, map[location]);\n\n  return mapper;\n}\n\nmodule.exports = createMapper;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/escapeRegExp.js":"\"use strict\";\n\n/**\n * Escapes all special RegExp characters in the given string.\n */\nfunction escapeRegExp(string) {\n  return String(string).replace(/([.?*+^$[\\]\\\\(){}-])/g, \"\\\\$1\");\n}\n\nmodule.exports = escapeRegExp;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/methodOverride.js":"\"use strict\";\n\nvar normalizeHeaderName = require(\"../utils/normalizeHeaderName\");\n\n/**\n * A middleware that overrides the method of the request to a value that was\n * given either in a request parameter or a request header. Can be useful when\n * you need to use HTTP methods other than GET and POST with clients that don't\n * support them, like web browsers.\n *\n * For example, you could use the following HTML form:\n *\n *   <form method=\"POST\" action=\"/\">\n *     <input type=\"hidden\" name=\"_method\" value=\"PUT\">\n *   </form>\n *\n * with an app that uses methodOverride:\n *\n *   var app = mach.stack();\n *   app.use(mach.params);\n *   app.use(mach.methodOverride);\n *   app.run(function (request) {\n *     return request.method; // PUT\n *   });\n *\n * Note: When using mach.methodOverride with POST parameters you need to put\n * mach.params in front of it so that the request parameters will be available.\n *\n * Options may be any of the following:\n *\n * - paramName        The name of the request param that contains the\n *                    request method. Defaults to \"_method\"\n * - headerName       The name of the HTTP header that will contain the\n *                    request method. This allows you to put the request\n *                    method in an HTTP header instead of a request param.\n *                    Defaults to \"X-Http-Method-Override\"\n */\nfunction methodOverride(app, options) {\n  options = options || {};\n\n  if (typeof options === \"string\") options = { paramName: options };\n\n  var paramName = options.paramName || \"_method\";\n  var headerName = normalizeHeaderName(options.headerName || \"X-Http-Method-Override\");\n\n  return function (conn) {\n    var method;\n    if (conn.request.headers[headerName]) {\n      method = conn.request.headers[headerName];\n    } else if (!conn.params) {\n      conn.onError(new Error(\"No params! Use mach.params in front of mach.methodOverride\"));\n    } else if (conn.params[paramName]) {\n      method = conn.params[paramName];\n\n      // If multiple _method parameters were used, use the last one.\n      if (Array.isArray(method)) method = method[method.length - 1];\n    }\n\n    if (method) conn.method = method.toUpperCase();\n\n    return conn.call(app);\n  };\n}\n\nmodule.exports = methodOverride;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/modified.js":"\"use strict\";\n\nvar stripQuotes = require(\"../utils/stripQuotes\");\n\n/**\n * A middleware that automatically performs content-based HTTP caching in\n * response to requests that use the If-None-Match and/or If-Modified-Since\n * headers. In order to work effectively, downstream apps must use the ETag\n * and/or Last-Modified headers.\n *\n * Example:\n *\n *   app.use(mach.modified);\n *\n *   // Send Last-Modified and ETag headers with static files.\n *   app.use(mach.file, {\n *     useLastModified: true, // this is the default\n *     useETag: true\n *   });\n */\nfunction modified(app) {\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var request = conn.request,\n          response = conn.response;\n\n      var ifNoneMatch = request.headers[\"If-None-Match\"];\n      var etag = response.headers.ETag;\n\n      if (ifNoneMatch && etag && etag === stripQuotes(ifNoneMatch)) {\n        conn.status = 304;\n        response.content = \"\";\n        return;\n      }\n\n      var ifModifiedSince = request.headers[\"If-Modified-Since\"];\n      var lastModified = response.headers[\"Last-Modified\"];\n\n      if (ifModifiedSince && lastModified) {\n        if (typeof lastModified === \"string\") lastModified = Date.parse(lastModified);\n\n        if (lastModified <= Date.parse(ifModifiedSince)) {\n          conn.status = 304;\n          response.content = \"\";\n        }\n      }\n    });\n  };\n}\n\nmodule.exports = modified;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/stripQuotes.js":"\"use strict\";\n\nfunction stripQuotes(string) {\n  if (string.substring(0, 1) === \"\\\"\") {\n    return string.replace(/^\"|\"$/g, \"\");\n  }return string;\n}\n\nmodule.exports = stripQuotes;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/params.js":"\"use strict\";\n\nvar objectAssign = require(\"object-assign\");\nvar mach = require(\"../index\");\nvar MaxLengthExceededError = require(\"../utils/MaxLengthExceededError\");\n\nmach.extend(require(\"../extensions/server\"));\n\n/**\n * Automatically parses all request parameters and stores them in conn.params.\n * This is the union of all GET (query string) and POST (content) parameters,\n * such that all POST parameters with the same name take precedence.\n *\n * Valid options are:\n *\n * - maxLength          The maximum length (in bytes) of the request content\n *\n * If the maximum allowed length is exceeded, this middleware returns a\n * 413 Request Entity Too Large response.\n *\n * Note: This middleware parses all request parameters for all downstream apps. If\n * you'd prefer to only do this work on some requests and not all, you can use\n * conn.getParams inside your app instead.\n */\nfunction parseParams(app, options) {\n  options = options || {};\n\n  if (typeof options === \"number\") options = { maxLength: options };\n\n  var maxLength = options.maxLength;\n\n  return function (conn) {\n    return conn.getParams(maxLength).then(function (params) {\n      if (conn.params) {\n        // Route params take precedence over content params.\n        conn.params = objectAssign(params, conn.params);\n      } else {\n        conn.params = params;\n      }\n\n      return conn.call(app);\n    }, function (error) {\n      if (error instanceof MaxLengthExceededError) return conn.text(413, \"Request Entity Too Large\");\n\n      throw error;\n    });\n  };\n}\n\nmodule.exports = parseParams;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/proxy.js":"\"use strict\";\n\nvar Location = require(\"../Location\");\nvar createProxy = require(\"../utils/createProxy\");\nvar isRegExp = require(\"../utils/isRegExp\");\n\nfunction returnTrue() {\n  return true;\n}\n\n/**\n * A middleware that forwards requests that pass the given test function\n * to the given target. If the target is not an app, it should be a string\n * or options hash that is used to create a proxy.\n *\n * Example:\n *\n *   var mach = require('mach');\n *   var app = mach.stack();\n *\n *   // Forward all requests to example.com.\n *   app.use(mach.proxy, 'http://www.example.com');\n *\n *   // Forward all requests that match \"/images/*.jpg\" to S3.\n *   app.use(mach.proxy, 'http://s3.amazon.com/my-bucket', /\\/images/*.jpg/);\n *   \n *   mach.serve(app);\n */\nfunction proxy(app, target, test) {\n  test = test || returnTrue;\n\n  if (isRegExp(test)) {\n    var pattern = test;\n    test = function (conn) {\n      return pattern.test(conn.href);\n    };\n  } else if (typeof test !== \"function\") {\n    throw new Error(\"mach.proxy needs a test function\");\n  }\n\n  var targetApp;\n  if (typeof target === \"function\") {\n    targetApp = target;\n  } else if (typeof target === \"string\" || target instanceof Location) {\n    targetApp = createProxy(target);\n  } else {\n    throw new Error(\"mach.proxy needs a target app\");\n  }\n\n  return function (conn) {\n    return conn.call(test(conn) ? targetApp : app);\n  };\n}\n\nmodule.exports = proxy;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/createProxy.js":"\"use strict\";\n\nvar Location = require(\"../Location\");\nvar sendRequest = require(\"./sendRequest\");\n\n/**\n * A proxy is a function that is used to forward a request to\n * a different location and return the response.\n *\n * This function is part of the low-level API and can generally be\n * used more conveniently through the mach.proxy middleware.\n */\nfunction createProxy(location) {\n  if (!(location instanceof Location)) location = new Location(location);\n\n  return function (conn) {\n    // Only concat the path from the connection so the protocol,\n    // auth, and host from the original location are preserved.\n    conn.proxyLocation = location.concat(conn.path);\n\n    return sendRequest(conn, conn.proxyLocation);\n  };\n}\n\nmodule.exports = createProxy;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/isRegExp.js":"\"use strict\";\n\nfunction isRegExp(object) {\n  return object != null && Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n\nmodule.exports = isRegExp;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/rewrite.js":"\"use strict\";\n\nvar escapeRegExp = require(\"../utils/escapeRegExp\");\nvar isRegExp = require(\"../utils/isRegExp\");\n\n/**\n * A middleware that provides URL rewriting behavior similar to Apache's\n * mod_rewrite. The pathname of requests that match the given pattern is\n * overwritten with the replacement using a simple String#replace.\n */\nfunction rewrite(app, pattern, replacement) {\n  if (typeof pattern === \"string\") pattern = new RegExp(\"^\" + escapeRegExp(pattern) + \"$\");\n\n  if (!isRegExp(pattern)) throw new Error(\"Rewrite pattern must be a RegExp or String\");\n\n  replacement = replacement || \"\";\n\n  return function (conn) {\n    var pathname = conn.pathname;\n\n    // Modify the pathname if the pattern matches.\n    if (pattern.test(pathname)) conn.location.properties.pathname = conn.basename + pathname.replace(pattern, replacement);\n\n    return conn.call(app);\n  };\n}\n\nmodule.exports = rewrite;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/router.js":"\"use strict\";\n\n/* jshint -W084 */\nvar d = require(\"describe-property\");\nvar objectAssign = require(\"object-assign\");\nvar compileRoute = require(\"../utils/compileRoute\");\nvar isRegExp = require(\"../utils/isRegExp\");\nvar makeParams = require(\"../utils/makeParams\");\nvar RoutingProperties = require(\"../utils/RoutingProperties\");\n\nvar LEADING_HTTP_METHOD_MATCHER = /^(DELETE|GET|HEAD|OPTIONS|POST|PUT|TRACE)\\s+(.+)$/;\n\n/**\n * A middleware that provides pattern-based routing for URLs, with optional\n * support for restricting matches to a specific request method. Named segments\n * of the URL are added to conn.params and take precedence over all others.\n *\n *   app.use(mach.router, {\n *\n *     'GET /login': function (conn) {\n *       // conn.method == 'GET'\n *       // conn.pathname == '/login'\n *     },\n *\n *     'POST /login': function (conn) {\n *       // conn.method == 'POST'\n *       // conn.pathname == '/login'\n *     },\n *\n *     'DELETE /users/:id': function (conn) {\n *       // conn.method == 'DELETE'\n *       // conn.pathname == '/users/5'\n *       // conn.params == { id: 5 }\n *     }\n *\n *   });\n *\n * This function may also be used outside the context of a middleware stack\n * to create a standalone app. Routes may be given one at a time:\n *\n *   var app = mach.router();\n *\n *   app.get('/login', function (conn) {\n *     // ...\n *   });\n *\n *   app.delete('/users/:id', function (conn) {\n *     // ...\n *   });\n *\n * Or all at once:\n *\n *   var app = mach.router({\n *\n *     'GET /login': function (conn) {\n *       // ...\n *     },\n *\n *     'DELETE /users/:id': function (conn) {\n *       // ...\n *     }\n *\n *   });\n *\n * Note: Routes are always tried in the order they were defined.\n */\nfunction createRouter(app, map) {\n  // Allow mach.router(map)\n  if (typeof app === \"object\") {\n    map = app;\n    app = null;\n  }\n\n  var routes = {};\n\n  function router(conn) {\n    var method = conn.method;\n    var routesToTry = (routes[method] || []).concat(routes.ANY || []);\n\n    var route, match;\n    for (var i = 0, len = routesToTry.length; i < len; ++i) {\n      route = routesToTry[i];\n\n      // Try to match the route.\n      if (match = route.pattern.exec(conn.pathname)) {\n        var params = makeParams(route.keys, Array.prototype.slice.call(match, 1));\n\n        if (conn.params) {\n          // Route params take precedence above all others.\n          objectAssign(conn.params, params);\n        } else {\n          conn.params = params;\n        }\n\n        return conn.call(route.app);\n      }\n    }\n\n    return conn.call(app);\n  }\n\n  Object.defineProperties(router, {\n\n    /**\n     * Adds a new route that runs the given app when the pattern matches the\n     * path used in the request. If the pattern is a string, it is automatically\n     * compiled. The following signatures are supported:\n     *\n     *   route('/users/:id', app)\n     *   route('/users/:id', 'PUT', app)\n     *   route('/users/:id', [ 'GET', 'PUT' ], app)\n     *   route('GET /users/:id', app)\n     */\n    route: d(function (pattern, methods, app) {\n      if (typeof methods === \"function\") {\n        app = methods;\n        methods = null;\n      }\n\n      if (typeof app !== \"function\") throw new Error(\"Route needs an app\");\n\n      if (typeof methods === \"string\") {\n        methods = [methods];\n      } else if (!Array.isArray(methods)) {\n        methods = [];\n      }\n\n      var keys = [];\n\n      if (typeof pattern === \"string\") {\n        var match;\n\n        if (match = pattern.match(LEADING_HTTP_METHOD_MATCHER)) {\n          methods.push(match[1]);\n          pattern = match[2];\n        }\n\n        pattern = compileRoute(pattern, keys);\n      }\n\n      if (!isRegExp(pattern)) throw new Error(\"Route pattern must be a RegExp\");\n\n      var route = { pattern: pattern, keys: keys, app: app };\n\n      if (methods.length === 0) methods.push(\"ANY\");\n\n      methods.forEach(function (method) {\n        var upperMethod = method.toUpperCase();\n\n        if (routes[upperMethod]) {\n          routes[upperMethod].push(route);\n        } else {\n          routes[upperMethod] = [route];\n        }\n      });\n    }),\n\n    /**\n     * Sets the given app as the default for this router.\n     */\n    run: d(function (downstreamApp) {\n      app = downstreamApp;\n    })\n\n  });\n\n  // Allow app.use(mach.router, map)\n  if (typeof map === \"object\") for (var route in map) if (map.hasOwnProperty(route)) router.route(route, map[route]);\n\n  Object.defineProperties(router, RoutingProperties);\n\n  return router;\n}\n\nmodule.exports = createRouter;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/compileRoute.js":"\"use strict\";\n\nvar paramMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|[*.()\\[\\]\\\\+|{}^$]/g;\n\n/**\n * Compiles the given route string into a RegExp that can be used to\n * match a URL. The route may contain named parameters in the form of\n * a colon followed by a valid JavaScript identifier (e.g. \":name\",\n * \":_name\", and \":$name\" are all valid parameters). The route may\n * also contain a * to match any character non-greedily, or a ? to\n * match the previous thing 0 or 1 time.\n *\n * The keys array is populated with names of all parameters in the\n * order they appear in the route string.\n */\nfunction compileRoute(route, keys) {\n  var source = route.replace(paramMatcher, function (match, key) {\n    if (key) {\n      keys.push(key);\n      return \"([^./?#]+)\";\n    } else if (match === \"*\") {\n      keys.push(\"splat\");\n      return \"(.*?)\";\n    } else {\n      return \"\\\\\" + match;\n    }\n  });\n\n  return new RegExp(\"^\" + source + \"$\", \"i\");\n}\n\nmodule.exports = compileRoute;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/makeParams.js":"\"use strict\";\n\nfunction makeParams(keys, values) {\n  return keys.reduce(function (params, key, index) {\n    var value = values[index];\n\n    if (key === \"splat\") {\n      if (Array.isArray(params.splat)) {\n        params.splat.push(value);\n      } else if (\"splat\" in params) {\n        // Multiple \"splat\" keys make an array.\n        params.splat = [params.splat, value];\n      } else {\n        params.splat = value;\n      }\n    } else {\n      params[key] = value;\n    }\n\n    return params;\n  }, {});\n}\n\nmodule.exports = makeParams;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/RoutingProperties.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\n\nvar RoutingMethods = {\n  \"delete\": \"DELETE\",\n  get: [\"GET\", \"HEAD\"],\n  head: \"HEAD\",\n  options: \"OPTIONS\",\n  post: \"POST\",\n  put: \"PUT\",\n  trace: \"TRACE\"\n};\n\nvar RoutingProperties = Object.keys(RoutingMethods).reduce(function (memo, method) {\n  memo[method] = d(function (pattern, app) {\n    return this.route(pattern, RoutingMethods[method], app);\n  });\n\n  return memo;\n}, {});\n\nmodule.exports = RoutingProperties;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/session.js":"\"use strict\";\n\nvar mach = require(\"../index\");\nvar Promise = require(\"../utils/Promise\");\nvar decodeBase64 = require(\"../utils/decodeBase64\");\nvar encodeBase64 = require(\"../utils/encodeBase64\");\nvar makeHash = require(\"../utils/makeHash\");\nvar CookieStore = require(\"./session/CookieStore\");\n\nmach.extend(require(\"../extensions/server\"));\n\n/**\n * The maximum size of an HTTP cookie.\n */\nvar MAX_COOKIE_SIZE = 4096;\n\n/**\n * Stores the given session and returns a promise for a value that should be stored\n * in the session cookie to retrieve the session data again on the next request.\n */\nfunction encodeSession(session, store, secret) {\n  return store.save(session).then(function (data) {\n    var cookie = encodeBase64(data + \"--\" + makeHashWithSecret(data, secret));\n\n    if (cookie.length > MAX_COOKIE_SIZE) throw new Error(\"Cookie data size exceeds 4kb; content dropped\");\n\n    return cookie;\n  });\n}\n\n/**\n * Decodes the given cookie value and returns a promise for the corresponding session\n * data from the store. Also verifies the hash value to ensure the cookie has not been\n * tampered with. If it has, returns null.\n */\nfunction decodeCookie(cookie, store, secret) {\n  var value = decodeBase64(cookie);\n  var index = value.lastIndexOf(\"--\");\n  var data = value.substring(0, index);\n  var hash = value.substring(index + 2);\n\n  // Verify the cookie has not been tampered with.\n  if (hash === makeHashWithSecret(data, secret)) {\n    return store.load(data);\n  }return null;\n}\n\nfunction makeHashWithSecret(data, secret) {\n  return makeHash(secret ? data + secret : data);\n}\n\n/**\n * A middleware that provides support for HTTP sessions using cookies.\n *\n * Options may be any of the following:\n *\n * - secret         A cryptographically secure secret key that will be used to verify\n *                  the integrity of session data that is received from the client\n * - name           The name of the cookie. Defaults to \"_session\"\n * - path           The path of the cookie. Defaults to \"/\"\n * - domain         The cookie's domain. Defaults to null\n * - secure         True to only send this cookie over HTTPS. Defaults to false\n * - expireAfter    The number of seconds after which sessions expire. Defaults\n *                  to 0 (no expiration)\n * - httpOnly       True to restrict access to this cookie to HTTP(S) APIs.\n *                  Defaults to true\n * - store          An instance of MemoryStore, CookieStore, or RedisStore that\n *                  is used to store session data. Defaults to a new CookieStore\n *\n * Example:\n *\n *   app.use(mach.session, {\n *     secret: 'the-secret',\n *     secure: true\n *   });\n *\n * Hint: A great way to generate a cryptographically secure session secret from\n * the command line:\n *\n *   $ node -p \"require('crypto').randomBytes(64).toString('hex')\"\n *\n * Note: Since cookies are only able to reliably store about 4k of data, if the\n * session cookie payload exceeds that the session will be dropped.\n */\nfunction session(app, options) {\n  options = options || {};\n\n  if (typeof options === \"string\") options = { secret: options };\n\n  var secret = options.secret;\n  var name = options.name || \"_session\";\n  var path = options.path || \"/\";\n  var domain = options.domain;\n  var expireAfter = options.expireAfter || 0;\n  var httpOnly = \"httpOnly\" in options ? options.httpOnly || false : true;\n  var secure = options.secure || false;\n  var store = options.store || new CookieStore(options);\n\n  if (!secret) {\n    console.warn([\"WARNING: There was no \\\"secret\\\" option provided to mach.session! This poses\", \"a security vulnerability because session data will be stored on clients without\", \"any server-side verification that it has not been tampered with. It is strongly\", \"recommended that you set a secret to prevent exploits that may be attempted using\", \"carefully crafted cookies.\"].join(\"\\n\"));\n  }\n\n  return function (conn) {\n    if (conn.session) return conn.call(app); // Don't overwrite the existing session.\n\n    var cookie = conn.request.cookies[name];\n\n    return Promise.resolve(cookie && decodeCookie(cookie, store, secret)).then(function (object) {\n      conn.session = object || {};\n\n      return conn.call(app).then(function () {\n        return Promise.resolve(conn.session && encodeSession(conn.session, store, secret)).then(function (newCookie) {\n          var expires = expireAfter && new Date(Date.now() + expireAfter * 1000);\n\n          // Don't bother setting the cookie if its value\n          // hasn't changed and there is no expires date.\n          if (newCookie === cookie && !expires) return;\n\n          conn.response.setCookie(name, {\n            value: newCookie,\n            path: path,\n            domain: domain,\n            expires: expires,\n            httpOnly: httpOnly,\n            secure: secure\n          });\n        }, conn.onError);\n      });\n    }, conn.onError);\n  };\n}\n\nmodule.exports = session;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/makeHash.js":"\"use strict\";\n\nvar crypto = require(\"crypto\");\n\n/**\n * Returns a SHA1 hash of the given string.\n */\nfunction makeHash(string) {\n  return crypto.createHash(\"sha1\").update(string).digest(\"hex\");\n}\n\nmodule.exports = makeHash;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/session/CookieStore.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar Promise = require(\"../../utils/Promise\");\n\n/**\n * Client-side storage for sessions using HTTP cookies.\n *\n * Accepts the following options:\n *\n * - expireAfter      The number of seconds after which sessions expire.\n *                    Defaults to 0 (no expiration)\n *\n * Note: Cookies are only able to reliably store about 4k of data. Also, sending\n * and receiving large cookies can have a significant impact on overall server\n * response time (see http://yuiblog.com/blog/2007/03/01/performance-research-part-3/).\n * For these reasons, if you are planning on storing a lot of data in the session\n * you may want to use a server-side storage, such as mach.session.RedisStore.\n */\nfunction CookieStore(options) {\n  options = options || {};\n\n  this.ttl = options.expireAfter ? 1000 * options.expireAfter : 0;\n}\n\nObject.defineProperties(CookieStore.prototype, {\n\n  load: d(function (value) {\n    var session;\n    try {\n      session = JSON.parse(value);\n    } catch (error) {\n      // Ignore invalid JSON data.\n      return Promise.resolve({});\n    }\n\n    // Verify the session is not expired.\n    if (session._expiry && session._expiry <= Date.now()) return Promise.resolve({});\n\n    return Promise.resolve(session);\n  }),\n\n  save: d(function (session) {\n    if (this.ttl) session._expiry = Date.now() + this.ttl;\n\n    return Promise.resolve(JSON.stringify(session));\n  })\n\n});\n\nmodule.exports = CookieStore;\n// expireAfter is given in seconds","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/stack.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar RoutingProperties = require(\"../utils/RoutingProperties\");\nvar createMapper = require(\"./mapper\");\nvar createRouter = require(\"./router\");\n\nfunction mapperCreator(mappings) {\n  return function (app) {\n    app = createMapper(app);\n\n    for (var i = 0, len = mappings.length; i < len; ++i) app.map.apply(app, mappings[i]);\n\n    return app;\n  };\n}\n\nfunction routerCreator(routes) {\n  return function (app) {\n    app = createRouter(app);\n\n    for (var i = 0, len = routes.length; i < len; ++i) app.route.apply(app, routes[i]);\n\n    return app;\n  };\n}\n\n/**\n * A middleware that aids in building complex apps that are fronted by other\n * middleware in a \"middleware stack\". Also provides several other useful methods\n * for request mapping and routing that make this middleware a good choice when\n * working with mach at a high level or when getting started for the first time.\n *\n * Middleware are placed into the stack by calling the `use` method which passes\n * along any additional arguments that it receives directly on to the middleware\n * when the stack is compiled.\n *\n * Other stacks can be \"mounted\" easily at various locations using the `map`\n * method. Routes can be added using `route`, `get`, `post`, etc. When a request\n * is received, all middleware, mappings, and routes run in the order they are\n * defined in the stack, top to bottom.\n *\n *   var app = mach.stack();\n *\n *   app.use(mach.gzip);\n *   app.use(mach.file, __dirname + '/public');\n *\n *   // Use an image server to serve requests that begin\n *   // with /images out of /public/img.\n *   app.map('/images', mach.file('/public/img'));\n *\n *   // Since this call is *after* the call to map, this middleware\n *   // will not run when requests begin with \"/images\".\n *   app.use(mach.params);\n *\n *   app.get('/', function (request) {\n *     return \"The params are: \" + JSON.stringify(request.params);\n *   });\n *\n *   app.post('/posts/:post_id/messages', function (request) {\n *     // ...\n *   });\n *\n *   mach.serve(app);\n *\n * Note: A stack is compiled the first time it is called. When a stack is\n * compiled, all middleware is invoked with the downstream app plus any\n * additional arguments that were passed to the call to stack.use. As long as\n * the stack doesn't change between requests, this happens only once.\n */\nfunction createStack(app) {\n  var layers = [],\n      mappings = [],\n      routes = [];\n  var compiledApp;\n\n  function compile(app) {\n    if (routes.length) app = routerCreator(routes)(app);\n\n    if (mappings.length) app = mapperCreator(mappings)(app);\n\n    var index = layers.length;\n\n    while (index) app = layers[--index].call(this, app);\n\n    return app;\n  }\n\n  function stack(conn) {\n    return conn.call(compiledApp || (compiledApp = compile(app)));\n  }\n\n  Object.defineProperties(stack, {\n\n    /**\n     * Declares that the given `middleware` should be used at the current point\n     * in the stack. Any additional arguments to this function are passed along\n     * to the middleware with the downstream app as the first argument when the\n     * stack is compiled.\n     */\n    use: d(function (middleware) {\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if (mappings.length) layers.push(mapperCreator(mappings.splice(0, mappings.length)));\n\n      if (routes.length) layers.push(routerCreator(routes.splice(0, routes.length)));\n\n      layers.push(function (app) {\n        return middleware.apply(this, [app].concat(args));\n      });\n\n      compiledApp = null;\n    }),\n\n    /**\n     * Uses a mapper to map a URL path to an app.\n     */\n    map: d(function (location, app) {\n      mappings.push([location, app]);\n      compiledApp = null;\n    }),\n\n    /**\n     * Uses a router to route URLs that match a pattern/method to an app.\n     */\n    route: d(function (pattern, methods, app) {\n      routes.push([pattern, methods, app]);\n      compiledApp = null;\n    }),\n\n    /**\n     * Sets the given app as the default for this stack.\n     */\n    run: d(function (downstreamApp) {\n      app = downstreamApp;\n      compiledApp = null;\n    })\n\n  });\n\n  Object.defineProperties(stack, RoutingProperties);\n\n  return stack;\n}\n\nmodule.exports = createStack;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/middleware/token.js":"\"use strict\";\n\nvar mach = require(\"../index\");\nvar makeToken = require(\"../utils/makeToken\");\n\nmach.extend(require(\"../extensions/server\"));\n\n/**\n * The set of HTTP request methods that are considered safe because they\n * do not alter server data.\n */\nvar SAFE_METHODS = {\n  GET: true,\n  HEAD: true,\n  OPTIONS: true,\n  TRACE: true\n};\n\n/**\n * A middleware that helps to prevent Cross-site Request Forgery attacks by\n * requiring the client to include an authentication token in all form\n * submissions that matches a value stored in the session cookie. See\n * http://www.codinghorror.com/blog/2008/10/preventing-csrf-and-xsrf-attacks.html\n *\n * If the session does not already have an authentication token one is\n * automatically generated and stored in the session. The default session key\n * is \"_token\". All form submissions need to include this value in the \"_token\"\n * parameter, like this:\n *\n *   <form method=\"POST\" action=\"/\">\n *     <input type=\"hidden\" name=\"_token\" value=\"{{session._token}}\">\n *   </form>\n *\n * On the backend, you need to put both mach.session and mach.params in front of\n * mach.token in order for it to be able to retrieve values from the request session\n * and parameters, like this:\n *\n *   app.use(mach.session);\n *   app.use(mach.params);\n *   app.use(mach.token);\n *   app.run(function (conn) {\n *     // The connection authenticated successfully\n *   });\n *\n * Options may be any of the following:\n *\n * - paramName        The name of the request parameter that contains the token\n *                    (i.e. the value of the \"name\" attribute on your <input>).\n *                    Defaults to \"_token\"\n * - sessionKey       The name of the session variable to use to store the token.\n *                    Defaults to \"_token\"\n * - byteLength       The length of the token in bytes. Defaults to 32\n *\n * Note: Non-POST requests are always forwarded to the downstream app regardless of\n * whether or not they contain the token since it is assumed they are not modifying\n * anything and are safe.\n */\nfunction verifyToken(app, options) {\n  options = options || {};\n\n  if (typeof options === \"string\") options = { paramName: options };\n\n  var paramName = options.paramName || \"_token\";\n  var sessionKey = options.sessionKey || \"_token\";\n  var byteLength = options.byteLength || 32;\n\n  return function (conn) {\n    var session = conn.session,\n        params = conn.params;\n\n    if (!session) {\n      conn.onError(new Error(\"No session! Use mach.session in front of mach.token\"));\n    } else if (!params) {\n      conn.onError(new Error(\"No params! Use mach.params in front of mach.token\"));\n    } else {\n      var token = session[sessionKey];\n\n      // Create a new session token if needed.\n      if (!token) token = session[sessionKey] = makeToken(byteLength);\n\n      if (params[paramName] && params[paramName] === token) return conn.call(app);\n    }\n\n    // If the request is not a POST we assume it's not a form submission\n    // and therefore not modifying anything. Pass it downstream.\n    if (SAFE_METHODS[conn.method] === true) return conn.call(app);\n\n    conn.text(403, \"Forbidden\");\n  };\n}\n\nmodule.exports = verifyToken;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/makeToken.js":"\"use strict\";\n\nvar crypto = require(\"crypto\");\n\n/**\n * Returns a cryptographically-secure string containing the\n * given number of bytes.\n */\nfunction makeToken(byteLength) {\n  return crypto.randomBytes(byteLength).toString(\"hex\");\n}\n\nmodule.exports = makeToken;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/proxy.js":"\"use strict\";\n\nmodule.exports = function (mach) {\n  mach.createProxy = require(\"../utils/createProxy\");\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/extensions/statusText.js":"\"use strict\";\n\nvar d = require(\"describe-property\");\nvar StatusCodes = require(\"../StatusCodes\");\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * The message that corresponds with the response status code.\n     */\n    statusText: d.gs(function () {\n      return this.status + \" \" + StatusCodes[this.status];\n    })\n\n  });\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/StatusCodes.js":"\"use strict\";\n\n/**\n * A map of HTTP status codes to their \"status text\".\n */\nmodule.exports = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\", // RFC 2518, obsoleted by RFC 4918\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\", // RFC 4918\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Moved Temporarily\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Time-out\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Request Entity Too Large\",\n  414: \"Request-URI Too Large\",\n  415: \"Unsupported Media Type\",\n  416: \"Requested Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a teapot\", // RFC 2324\n  422: \"Unprocessable Entity\", // RFC 4918\n  423: \"Locked\", // RFC 4918\n  424: \"Failed Dependency\", // RFC 4918\n  425: \"Unordered Collection\", // RFC 4918\n  426: \"Upgrade Required\", // RFC 2817\n  428: \"Precondition Required\", // RFC 6585\n  429: \"Too Many Requests\", // RFC 6585\n  431: \"Request Header Fields Too Large\", // RFC 6585\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\", // RFC 2295\n  507: \"Insufficient Storage\", // RFC 4918\n  509: \"Bandwidth Limit Exceeded\",\n  510: \"Not Extended\", // RFC 2774\n  511: \"Network Authentication Required\" // RFC 6585\n};","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/lib/utils/callApp.js":"\"use strict\";\n\nvar Connection = require(\"../Connection\");\nvar Promise = require(\"./Promise\");\n\n/**\n * Creates a new Connection using the given options and sends\n * the request to the given app. Returns a promise for the connection\n * object when the response is received.\n *\n * Options may be any of the Connection options, plus the following:\n *\n * - binary     By default the response content is buffered and stored\n *              in the responseText property of the connection. Set this\n *              option true to disable this behavior.\n * - maxLength  The maximum length of the response content to accept.\n *              This option has no effect when \"binary\" is true. By\n *              default there is no maximum length.\n * - encoding   The encoding to use to decode the response body. This\n *              option has no effect when \"binary\" is true. By default\n *              the encoding is whatever was specified in the Content-Type\n *              header of the response.\n *\n * If a modifier function is provided, it will have a chance to modify\n * the Connection object immediately before the request is made.\n */\nfunction callApp(app, options, modifier) {\n  options = options || {};\n\n  var c = new Connection(options);\n\n  return Promise.resolve(modifier ? modifier(c) : c).then(function (conn) {\n    if (conn == null || !(conn instanceof Connection)) conn = c;\n\n    return conn.call(app).then(function () {\n      if (options.binary) return conn;\n\n      return conn.response.stringifyContent(options.maxLength, options.encoding).then(function (content) {\n        conn.responseText = content;\n        return conn;\n      });\n    });\n  });\n}\n\nmodule.exports = callApp;","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/karma.conf.js":"module.exports = function (config) {\n  config.set({\n\n    browsers: [ 'Chrome' ],\n\n    frameworks: [ 'mocha' ],\n\n    files: [\n      'tests.webpack.js'\n    ],\n\n    preprocessors: {\n      'tests.webpack.js': [ 'webpack', 'sourcemap' ]\n    },\n\n    webpack: {\n      devtool: 'inline-source-map',\n      module: {\n        loaders: [\n          { test: /\\.js$/, exclude: /node_modules/, loader: 'babel' }\n        ]\n      },\n      plugins: [\n        new webpack.DefinePlugin({\n          'process.env.NODE_ENV': JSON.stringify('test')\n        })\n      ]\n    },\n\n    webpackServer: {\n      noInfo: true\n    }\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/webpack.config.js":"var webpack = require('webpack');\n\nvar plugins = [\n  new webpack.DefinePlugin({\n    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)\n  })\n];\n\nif (process.env.COMPRESS) {\n  plugins.push(\n    new webpack.optimize.UglifyJsPlugin({\n      compressor: {\n        warnings: false\n      }\n    })\n  );\n}\n\nmodule.exports = {\n\n  output: {\n    library: 'mach',\n    libraryTarget: 'umd'\n  },\n\n  module: {\n    loaders: [\n      { test: /\\.js$/, exclude: /node_modules/, loader: 'babel' }\n    ]\n  },\n\n  node: {\n    buffer: false,\n    process: false\n  },\n\n  plugins: plugins\n\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/Connection.js":"/* jshint -W058 */\nvar d = require('describe-property');\nvar isBinary = require('bodec').isBinary;\nvar decodeBase64 = require('./utils/decodeBase64');\nvar encodeBase64 = require('./utils/encodeBase64');\nvar stringifyQuery = require('./utils/stringifyQuery');\nvar Promise = require('./utils/Promise');\nvar Location = require('./Location');\nvar Message = require('./Message');\n\nfunction locationPropertyAlias(name) {\n  return d.gs(function () {\n    return this.location[name];\n  }, function (value) {\n    this.location[name] = value;\n  });\n}\n\nfunction defaultErrorHandler(error) {\n  if (typeof console !== 'undefined' && console.error) {\n    console.error((error && error.stack) || error);\n  } else {\n    throw error; // Don't silently swallow errors!\n  }\n}\n\nfunction defaultCloseHandler() {}\n\nfunction defaultApp(conn) {\n  conn.status = 404;\n  conn.response.contentType = 'text/plain';\n  conn.response.content = 'Not found: ' + conn.method + ' ' + conn.path;\n}\n\n/**\n * An HTTP connection that acts as the asynchronous primitive for\n * the duration of the request/response cycle.\n *\n * Important features are:\n *\n * - request        A Message representing the request being made. In\n *                  a server environment, this is an \"incoming\" message\n *                  that was probably generated by a web browser or some\n *                  other consumer. In a client environment, this is an\n *                  \"outgoing\" message that we send to a remote server.\n * - response       A Message representing the response to the request.\n *                  In a server environment, this is an \"outgoing\" message\n *                  that will be sent back to the client. In a client\n *                  environment, this is the response that was received\n *                  from the remote server.\n * - method         The HTTP method that the request uses\n * - location       The URL of the request. In a server environment, this\n *                  is derived from the URL path used in the request as\n *                  well as a combination of the Host, X-Forwarded-* and\n *                  other relevant headers.\n * - version        The version of HTTP used in the request\n * - status         The HTTP status code of the response\n * - statusText     The HTTP status text that corresponds to the status\n * - responseText   This is a special property that contains the entire\n *                  content of the response. It is present by default when\n *                  making client requests for convenience, but may also be\n *                  disabled when you need to stream the response.\n *\n * Options may be any of the following:\n *\n * - content        The request content, defaults to \"\"\n * - headers        The request headers, defaults to {}\n * - method         The request HTTP method, defaults to \"GET\"\n * - location/url   The request Location or URL\n * - params         The request params\n * - onError        A function that is called when there is an error\n * - onClose        A function that is called when the request closes\n *\n * The options may also be a URL string to specify the URL.\n */\nfunction Connection(options) {\n  options = options || {};\n\n  var location;\n  if (typeof options === 'string') {\n    location = options; // options may be a URL string.\n  } else if (options.location || options.url) {\n    location = options.location || options.url;\n  } else if (typeof window === 'object') {\n    location = window.location.href;\n  }\n\n  this.location = location;\n  this.version = options.version || '1.1';\n  this.method = options.method;\n\n  this.onError = (options.onError || defaultErrorHandler).bind(this);\n  this.onClose = (options.onClose || defaultCloseHandler).bind(this);\n  this.request = new Message(options.content, options.headers);\n  this.response = new Message;\n\n  // Params may be given as an object.\n  if (options.params) {\n    if (this.method === 'GET' || this.method === 'HEAD') {\n      this.query = options.params;\n    } else {\n      this.request.contentType = 'application/x-www-form-urlencoded';\n      this.request.content = stringifyQuery(options.params);\n    }\n  }\n\n  this.withCredentials = options.withCredentials || false;\n  this.remoteHost = options.remoteHost || null;\n  this.remoteUser = options.remoteUser || null;\n  this.basename = '';\n\n  this.responseText = null;\n  this.status = 200;\n}\n\nObject.defineProperties(Connection.prototype, {\n\n  /**\n   * The method used in the request.\n   */\n  method: d.gs(function () {\n    return this._method;\n  }, function (value) {\n    this._method = typeof value === 'string' ? value.toUpperCase() : 'GET';\n  }),\n\n  /**\n   * The Location of the request.\n   */\n  location: d.gs(function () {\n    return this._location;\n  }, function (value) {\n    this._location = (value instanceof Location) ? value : new Location(value);\n  }),\n\n  href: locationPropertyAlias('href'),\n  protocol: locationPropertyAlias('protocol'),\n  host: locationPropertyAlias('host'),\n  hostname: locationPropertyAlias('hostname'),\n  port: locationPropertyAlias('port'),\n  search: locationPropertyAlias('search'),\n  queryString: locationPropertyAlias('queryString'),\n  query: locationPropertyAlias('query'),\n\n  /**\n   * True if the request uses SSL, false otherwise.\n   */\n  isSSL: d.gs(function () {\n    return this.protocol === 'https:';\n  }),\n\n  /**\n   * The username:password used in the request, an empty string\n   * if no auth was provided.\n   */\n  auth: d.gs(function () {\n    var header = this.request.headers['Authorization'];\n\n    if (header) {\n      var parts = header.split(' ', 2);\n      var scheme = parts[0];\n\n      if (scheme.toLowerCase() === 'basic')\n        return decodeBase64(parts[1]);\n\n      return header;\n    }\n\n    return this.location.auth;\n  }, function (value) {\n    var headers = this.request.headers;\n\n    if (value && typeof value === 'string') {\n      headers['Authorization'] = 'Basic ' + encodeBase64(value);\n    } else {\n      delete headers['Authorization'];\n    }\n  }),\n\n  /**\n   * The portion of the original URL path that is still relevant\n   * for request processing.\n   */\n  pathname: d.gs(function () {\n    return this.location.pathname.replace(this.basename, '') || '/';\n  }, function (value) {\n    this.location.pathname = this.basename + value;\n  }),\n\n  /**\n   * The URL path with query string.\n   */\n  path: d.gs(function () {\n    return this.pathname + this.search;\n  }, function (value) {\n    this.location.path = this.basename + value;\n  }),\n\n  /**\n   * Calls the given `app` with this connection as the only argument.\n   * as the first argument and returns a promise for a Response.\n   */\n  call: d(function (app) {\n    app = app || defaultApp;\n\n    var conn = this;\n\n    try {\n      return Promise.resolve(app(conn)).then(function (value) {\n        if (value == null)\n          return;\n\n        if (typeof value === 'number') {\n          conn.status = value;\n        } else if (typeof value === 'string' || isBinary(value) || typeof value.pipe === 'function') {\n          conn.response.content = value;\n        } else {\n          if (value.headers != null)\n            conn.response.headers = value.headers;\n\n          if (value.content != null)\n            conn.response.content = value.content;\n\n          if (value.status != null)\n            conn.status = value.status;\n        }\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  })\n\n});\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/decodeBase64.js":"module.exports = require('bodec').decodeBase64;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/encodeBase64.js":"module.exports = require('bodec').encodeBase64;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/stringifyQuery.js":"module.exports = require('qs').stringify;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/Promise.js":"var Promise = require('when/lib/Promise');\n\nif (process.env.NODE_ENV !== 'production')\n  require('when/monitor')(Promise);\n\nmodule.exports = Promise;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/Location.js":"var d = require('describe-property');\nvar mergeQuery = require('./utils/mergeQuery');\nvar stringifyQuery = require('./utils/stringifyQuery');\nvar parseQuery = require('./utils/parseQuery');\nvar parseURL = require('./utils/parseURL');\n\n/**\n * Standard ports for HTTP protocols.\n */\nvar STANDARD_PORTS = {\n  'http:': '80',\n  'https:': '443'\n};\n\nfunction propertyAlias(propertyName, defaultValue) {\n  return d.gs(function () {\n    return this.properties[propertyName] || (defaultValue == null ? null : defaultValue);\n  }, function (value) {\n    this.properties[propertyName] = value;\n  });\n}\n\n// Order is important here. Later properties take priority.\nvar PROPERTY_NAMES = [ 'protocol', 'auth', 'hostname', 'port', 'host', 'pathname', 'search', 'queryString', 'query', 'path' ];\n\nfunction setProperties(location, properties) {\n  var propertyName;\n  for (var i = 0, len = PROPERTY_NAMES.length; i < len; ++i) {\n    propertyName = PROPERTY_NAMES[i];\n\n    if (properties.hasOwnProperty(propertyName) && propertyName in location)\n      location[propertyName] = properties[propertyName];\n  }\n}\n\n/**\n * A URL location, analogous to window.location.\n *\n * Options may be any of the following:\n *\n * - protocol\n * - auth\n * - hostname\n * - port\n * - host (overrides hostname and port)\n * - pathname\n * - search\n * - queryString (overrides search)\n * - query (overrides queryString/search)\n * - path (overrides pathname and query/queryString/search)\n *\n * Alternatively, options may be a URL string.\n */\nfunction Location(options) {\n  this.properties = {};\n\n  if (typeof options === 'string') {\n    this.href = options;\n  } else if (options) {\n    setProperties(this, options);\n  }\n}\n\nObject.defineProperties(Location.prototype, {\n\n  /**\n   * Creates and returns a new Location with the path and query of\n   * the given location appended.\n   */\n  concat: d(function (location) {\n    if (!(location instanceof Location))\n      location = new Location(location);\n\n    var pathname = this.pathname;\n    var extraPathname = location.pathname;\n\n    if (extraPathname !== '/')\n      pathname = pathname.replace(/\\/*$/, '/') + extraPathname.replace(/^\\/*/, '');\n\n    var query = mergeQuery(this.query, location.query);\n\n    return new Location({\n      protocol: location.protocol || this.protocol,\n      auth: location.auth || this.auth,\n      hostname: location.hostname || this.hostname,\n      port: location.port || this.port,\n      pathname: pathname,\n      query: query\n    });\n  }),\n\n  /**\n   * The full URL.\n   */\n  href: d.gs(function () {\n    var auth = this.auth;\n    var host = this.host;\n    var path = this.path;\n\n    return host ? (this.protocol + '//' + (auth ? auth + '@' : '') + host + path) : path;\n  }, function (value) {\n    var parsed = parseURL(value);\n\n    setProperties(this, {\n      protocol: parsed.protocol,\n      auth: parsed.auth,\n      hostname: parsed.hostname,\n      port: parsed.port,\n      pathname: parsed.pathname,\n      search: parsed.search\n    });\n  }),\n\n  /**\n   * The portion of the URL that denotes the protocol, including the\n   * trailing colon (e.g. \"http:\" or \"https:\").\n   */\n  protocol: propertyAlias('protocol'),\n\n  /**\n   * The username:password used in the URL, if any.\n   */\n  auth: propertyAlias('auth', ''),\n\n  /**\n   * The full name of the host, including the port number when using\n   * a non-standard port.\n   */\n  host: d.gs(function () {\n    var protocol = this.protocol;\n    var host = this.hostname;\n    var port = this.port;\n\n    if (port != null && port !== STANDARD_PORTS[protocol])\n      host += ':' + port;\n\n    return host;\n  }, function (value) {\n    var index;\n\n    if (typeof value === 'string' && (index = value.indexOf(':')) !== -1) {\n      this.hostname = value.substring(0, index);\n      this.port = value.substring(index + 1);\n    } else {\n      this.hostname = value;\n      this.port = null;\n    }\n  }),\n\n  /**\n   * The name of the host without the port.\n   */\n  hostname: propertyAlias('hostname'),\n\n  /**\n   * The port number as a string.\n   */\n  port: d.gs(function () {\n    return this.properties.port || (this.protocol ? STANDARD_PORTS[this.protocol] : null);\n  }, function (value) {\n    this.properties.port = value ? String(value) : null;\n  }),\n\n  /**\n   * The URL path without the query string.\n   */\n  pathname: propertyAlias('pathname', '/'),\n\n  /**\n   * The URL path with query string.\n   */\n  path: d.gs(function () {\n    return this.pathname + this.search;\n  }, function (value) {\n    var index;\n\n    if (typeof value === 'string' && (index = value.indexOf('?')) !== -1) {\n      this.pathname = value.substring(0, index);\n      this.search = value.substring(index);\n    } else {\n      this.pathname = value;\n      this.search = null;\n    }\n  }),\n\n  /**\n   * The query string, including the preceeding ?.\n   */\n  search: propertyAlias('search', ''),\n\n  /**\n   * The query string of the URL, without the preceeding ?.\n   */\n  queryString: d.gs(function () {\n    return this.search.substring(1);\n  }, function (value) {\n    this.search = value && '?' + value;\n  }),\n\n  /**\n   * An object of data in the query string.\n   */\n  query: d.gs(function () {\n    return parseQuery(this.queryString);\n  }, function (value) {\n    this.queryString = stringifyQuery(value);\n  }),\n\n  toJSON: d(function () {\n    return this.href;\n  }),\n\n  toString: d(function () {\n    return this.href;\n  })\n\n});\n\nmodule.exports = Location;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/mergeQuery.js":"module.exports = require('qs/lib/utils').merge;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/parseQuery.js":"module.exports = require('qs').parse;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/parseURL.js":"var urlParse = require('url').parse;\n\nfunction parseURL(url) {\n  var parsed = urlParse(url);\n\n  return {\n    protocol: parsed.protocol,\n    auth: parsed.auth,\n    hostname: parsed.hostname,\n    port: parsed.port,\n    pathname: parsed.pathname,\n    search: parsed.search,\n    hash: parsed.hash\n  };\n}\n\nmodule.exports = parseURL;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/Message.js":"var bodec = require('bodec');\nvar d = require('describe-property');\nvar Stream = require('bufferedstream');\nvar bufferStream = require('./utils/bufferStream');\nvar normalizeHeaderName = require('./utils/normalizeHeaderName');\nvar parseCookie = require('./utils/parseCookie');\nvar parseQuery = require('./utils/parseQuery');\n\n/**\n * The default content to use for new messages.\n */\nvar DEFAULT_CONTENT = bodec.fromString('');\n\n/**\n * The default maximum length (in bytes) to use in Message#parseContent.\n */\nvar DEFAULT_MAX_CONTENT_LENGTH = Math.pow(2, 20); // 1M\n\nvar HEADERS_LINE_SEPARATOR = /\\r?\\n/;\nvar HEADER_SEPARATOR = ': ';\n\nfunction defaultParser(message, maxLength) {\n  return message.stringifyContent(maxLength);\n}\n\n/**\n * An HTTP message.\n */\nfunction Message(content, headers) {\n  this.headers = headers;\n  this.content = content;\n}\n\nObject.defineProperties(Message, {\n\n  PARSERS: d({\n    enumerable: true,\n    value: {\n      'application/json': function (message, maxLength) {\n        return message.stringifyContent(maxLength).then(JSON.parse);\n      },\n      'application/x-www-form-urlencoded': function (message, maxLength) {\n        return message.stringifyContent(maxLength).then(parseQuery);\n      }\n    }\n  })\n\n});\n\nObject.defineProperties(Message.prototype, {\n\n  /**\n   * The headers of this message as { headerName, value }.\n   */\n  headers: d.gs(function () {\n    return this._headers;\n  }, function (value) {\n    this._headers = {};\n\n    if (typeof value === 'string') {\n      value.split(HEADERS_LINE_SEPARATOR).forEach(function (line) {\n        var index = line.indexOf(HEADER_SEPARATOR);\n\n        if (index === -1) {\n          this.addHeader(line, true);\n        } else {\n          this.addHeader(line.substring(0, index), line.substring(index + HEADER_SEPARATOR.length));\n        }\n      }, this);\n    } else if (value != null) {\n      for (var headerName in value)\n        if (value.hasOwnProperty(headerName))\n          this.addHeader(headerName, value[headerName]);\n    }\n  }),\n\n  /**\n   * Returns the value of the header with the given name.\n   */\n  getHeader: d(function (headerName) {\n    return this.headers[normalizeHeaderName(headerName)];\n  }),\n\n  /**\n   * Sets the value of the header with the given name.\n   */\n  setHeader: d(function (headerName, value) {\n    this.headers[normalizeHeaderName(headerName)] = value;\n  }),\n\n  /**\n   * Adds the value to the header with the given name.\n   */\n  addHeader: d(function (headerName, value) {\n    headerName = normalizeHeaderName(headerName);\n\n    var headers = this.headers;\n    if (headerName in headers) {\n      if (Array.isArray(headers[headerName])) {\n        headers[headerName].push(value);\n      } else {\n        headers[headerName] = [ headers[headerName], value ];\n      }\n    } else {\n      headers[headerName] = value;\n    }\n  }),\n\n  /**\n   * An object containing cookies in this message, keyed by name.\n   */\n  cookies: d.gs(function () {\n    if (!this._cookies) {\n      var header = this.headers['Cookie'];\n\n      if (header) {\n        var cookies = parseCookie(header);\n\n        // From RFC 2109:\n        // If multiple cookies satisfy the criteria above, they are ordered in\n        // the Cookie header such that those with more specific Path attributes\n        // precede those with less specific. Ordering with respect to other\n        // attributes (e.g., Domain) is unspecified.\n        for (var cookieName in cookies)\n          if (Array.isArray(cookies[cookieName]))\n            cookies[cookieName] = cookies[cookieName][0] || '';\n\n        this._cookies = cookies;\n      } else {\n        this._cookies = {};\n      }\n    }\n\n    return this._cookies;\n  }),\n\n  /**\n   * Gets/sets the value of the Content-Type header.\n   */\n  contentType: d.gs(function () {\n    return this.headers['Content-Type'];\n  }, function (value) {\n    this.headers['Content-Type'] = value;\n  }),\n\n  /**\n   * The media type (type/subtype) portion of the Content-Type header without any\n   * media type parameters. e.g. when Content-Type is \"text/plain;charset=utf-8\",\n   * the mediaType is \"text/plain\".\n   *\n   * See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7\n   */\n  mediaType: d.gs(function () {\n    var contentType = this.contentType, match;\n    return (contentType && (match = contentType.match(/^([^;,]+)/))) ? match[1].toLowerCase() : null;\n  }, function (value) {\n    this.contentType = value + (this.charset ? ';charset=' + this.charset : '');\n  }),\n\n  /**\n   * Returns the character set used to encode the content of this message. e.g.\n   * when Content-Type is \"text/plain;charset=utf-8\", charset is \"utf-8\".\n   *\n   * See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.4\n   */\n  charset: d.gs(function () {\n    var contentType = this.contentType, match;\n    return (contentType && (match = contentType.match(/\\bcharset=([\\w-]+)/))) ? match[1] : null;\n  }, function (value) {\n    this.contentType = this.mediaType + (value ? ';charset=' + value : '');\n  }),\n\n  /**\n   * The content of this message as a binary stream.\n   */\n  content: d.gs(function () {\n    return this._content;\n  }, function (value) {\n    if (value == null)\n      value = DEFAULT_CONTENT;\n\n    if (value instanceof Stream) {\n      this._content = value;\n      value.pause();\n    } else {\n      this._content = new Stream(value);\n    }\n\n    delete this._bufferedContent;\n  }),\n\n  /**\n   * True if the content of this message is buffered, false otherwise.\n   */\n  isBuffered: d.gs(function () {\n    return this._bufferedContent != null;\n  }),\n\n  /**\n   * Returns a binary representation of the content of this message up to\n   * the given length. This is useful in applications that need to access the\n   * entire message body at once, instead of as a stream.\n   *\n   * Note: 0 is a valid value for maxLength. It means \"no limit\".\n   */\n  bufferContent: d(function (maxLength) {\n    if (this._bufferedContent == null)\n      this._bufferedContent = bufferStream(this.content, maxLength);\n\n    return this._bufferedContent;\n  }),\n\n  /**\n   * Returns the content of this message up to the given length as a string\n   * with the given encoding.\n   *\n   * Note: 0 is a valid value for maxLength. It means \"no limit\".\n   */\n  stringifyContent: d(function (maxLength, encoding) {\n    encoding = encoding || this.charset;\n\n    return this.bufferContent(maxLength).then(function (chunk) {\n      return bodec.toString(chunk, encoding);\n    });\n  }),\n\n  /**\n   * Returns a promise for an object of data contained in the content body.\n   *\n   * The maxLength argument specifies the maximum length (in bytes) that the\n   * parser will accept. If the content stream exceeds the maximum length, the\n   * promise is rejected with a MaxLengthExceededError. The appropriate response\n   * to send to the client in this case is 413 Request Entity Too Large, but\n   * many HTTP clients including most web browsers may not understand it.\n   *\n   * Note: 0 is a valid value for maxLength. It means \"no limit\".\n   */\n  parseContent: d(function (maxLength) {\n    if (this._parsedContent)\n      return this._parsedContent;\n\n    if (typeof maxLength !== 'number')\n      maxLength = DEFAULT_MAX_CONTENT_LENGTH;\n\n    var parser = Message.PARSERS[this.mediaType] || defaultParser;\n    this._parsedContent = parser(this, maxLength);\n\n    return this._parsedContent;\n  })\n\n});\n\nmodule.exports = Message;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/bufferStream.js":"var bodec = require('bodec');\nvar Promise = require('./Promise');\nvar MaxLengthExceededError = require('./MaxLengthExceededError');\n\n/**\n * Returns a promise for a buffer of all content in the given stream up to\n * the given maximum length.\n */\nfunction bufferStream(stream, maxLength) {\n  maxLength = maxLength || Infinity;\n\n  if (!stream.readable)\n    throw new Error('Cannot buffer stream that is not readable');\n\n  return new Promise(function (resolve, reject) {\n    var chunks = [];\n    var length = 0;\n\n    stream.on('error', reject);\n\n    stream.on('data', function (chunk) {\n      length += chunk.length;\n\n      if (length > maxLength) {\n        reject(new MaxLengthExceededError(maxLength));\n      } else {\n        chunks.push(chunk);\n      }\n    });\n\n    stream.on('end', function () {\n      resolve(bodec.join(chunks));\n    });\n\n    if (typeof stream.resume === 'function')\n      stream.resume();\n  });\n}\n\nmodule.exports = bufferStream;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/MaxLengthExceededError.js":"var d = require('describe-property');\n\n/**\n * An error indicating that some maximum length has been exceeded.\n */\nfunction MaxLengthExceededError(maxLength) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = 'Maximum length exceeded';\n  this.maxLength = maxLength;\n}\n\nMaxLengthExceededError.prototype = Object.create(Error.prototype, {\n\n  constructor: d(MaxLengthExceededError)\n\n});\n\nmodule.exports = MaxLengthExceededError;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/normalizeHeaderName.js":"var IrregularHeaderNames = require('./IrregularHeaderNames');\n\n/**\n * Normalizes HTTP header names according to RFC 2616.\n */\nfunction normalizeHeaderName(headerName) {\n  headerName = headerName.toLowerCase();\n\n  if (headerName in IrregularHeaderNames)\n    return IrregularHeaderNames[headerName];\n\n  return headerName.replace(/(^|-)([a-z])/g, function (match, dash, letter) {\n    return dash + letter.toUpperCase();\n  });\n}\n\nmodule.exports = normalizeHeaderName;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/IrregularHeaderNames.js":"/**\n * A map of HTTP header names with irregular case.\n */\nmodule.exports = [\n  'Content-ID',\n  'Content-MD5',\n  'DNT',\n  'ETag',\n  'P3P',\n  'TE',\n  'WWW-Authenticate',\n  'X-ATT-DeviceId',\n  'X-UA-Compatible',\n  'X-WebKit-CSP',\n  'X-XSS-Protection'\n].reduce(function (map, headerName) {\n  map[headerName.toLowerCase()] = headerName;\n  return map;\n}, {});\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/parseCookie.js":"var parseQuery = require('./parseQuery');\n\nfunction parseCookie(cookie) {\n  return parseQuery(cookie, { delimiter: /[;,] */ });\n}\n\nmodule.exports = parseCookie;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/Header.js":"var normalizeHeaderName = require('./utils/normalizeHeaderName');\n\nclass Header {\n\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  set name(value) {\n    this._name = normalizeHeaderName(value);\n  }\n\n  toString() {\n    return this.name + ': ' + this.value;\n  }\n\n}\n\nmodule.exports = Header;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/index.js":"var EXTENSIONS = [];\n\n/*!\n * mach - HTTP for JavaScript\n * https://github.com/mjackson/mach\n */\nvar mach = module.exports = {\n\n  version: require('./version'),\n  Connection: require('./Connection'),\n  Header: require('./Header'),\n  Location: require('./Location'),\n  Message: require('./Message'),\n\n  extend: function () {\n    var extension;\n    for (var i = 0, len = arguments.length; i < len; ++i) {\n      extension = arguments[i];\n\n      if (EXTENSIONS.indexOf(extension) === -1) {\n        EXTENSIONS.push(extension);\n        extension(mach);\n      }\n    }\n  }\n\n};\n\nmach.extend(require('./extensions/default'));\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/version.js":"/**\n * The current version of mach.\n */\nmodule.exports = '1.3.5';\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/default.js":"/**\n * The default extension for node.js environments.\n */\nmodule.exports = function (mach) {\n  mach.extend(\n    require('./accept'),\n    require('./acceptCharset'),\n    require('./acceptEncoding'),\n    require('./acceptLanguage'),\n    require('./client'),\n    require('./middleware'),\n    require('./multipart'),\n    require('./proxy'),\n    require('./server'),\n    require('./statusText')\n  );\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/accept.js":"var d = require('describe-property');\nvar Accept = require('../headers/Accept');\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given media type.\n     */\n    accepts: d(function (mediaType) {\n      return this.request.accepts(mediaType);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given media type.\n     */\n    accepts: d(function (mediaType) {\n      if (!this._acceptHeader)\n        this._acceptHeader = new Accept(this.headers['Accept']);\n\n      return this._acceptHeader.accepts(mediaType);\n    })\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/headers/Accept.js":"var parseMediaValue = require('../utils/parseMediaValue');\nvar parseMediaValues = require('../utils/parseMediaValues');\nvar qualityFactorForMediaValue = require('../utils/qualityFactorForMediaValue');\nvar stringifyMediaValues = require('../utils/stringifyMediaValues');\nvar stringifyMediaValueWithoutQualityFactor = require('../utils/stringifyMediaValueWithoutQualityFactor');\nvar Header = require('../Header');\n\nfunction paramsMatchIgnoringQualityFactor(params, givenParams) {\n  for (var paramName in params)\n    if (params.hasOwnProperty(paramName) && paramName !== 'q' && givenParams[paramName] !== params[paramName])\n      return false;\n\n  return true;\n}\n\nfunction byHighestPrecedence(a, b) {\n  //   Accept: text/*, text/html, text/html;level=1, */*\n  //\n  // have the following precedence:\n  //\n  //   1) text/html;level=1\n  //   2) text/html\n  //   3) text/*\n  //   4) */*\n  return stringifyMediaValueWithoutQualityFactor(b).length - stringifyMediaValueWithoutQualityFactor(a).length;\n}\n\n/**\n * Represents an HTTP Accept header and provides several methods for\n * determining acceptable media types.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1\n */\nclass Accept extends Header {\n\n  constructor(value) {\n    super('Accept', value);\n  }\n\n  /**\n   * Returns the value of this header as a string.\n   */\n  get value() {\n    return stringifyMediaValues(this._mediaValues) || '*/*';\n  }\n\n  set value(value) {\n    this._mediaValues = value ? parseMediaValues(value) : [];\n  }\n\n  /**\n   * Returns true if the given media type is acceptable.\n   */\n  accepts(mediaType) {\n    return this.qualityFactorForMediaType(mediaType) !== 0;\n  }\n\n  /**\n   * Returns the quality factor for the given media type.\n   */\n  qualityFactorForMediaType(mediaType) {\n    var values = this._mediaValues;\n\n    if (!values.length)\n      return 1;\n\n    var givenValue = parseMediaValue(mediaType);\n    var matchingValues = values.filter(function (value) {\n      return (value.type === '*' || value.type === givenValue.type) &&\n             (value.subtype === '*' || value.subtype === givenValue.subtype) &&\n             paramsMatchIgnoringQualityFactor(value.params, givenValue.params);\n    }).sort(byHighestPrecedence);\n\n    if (!matchingValues.length)\n      return 0;\n\n    return qualityFactorForMediaValue(matchingValues[0]);\n  }\n\n}\n\nmodule.exports = Accept;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/parseMediaValue.js":"/**\n * Parses a media value string including parameters and returns an object\n * containing the type, subtype, and an object of parameters.\n *\n *   parseMediaValue(\"text/html;level=2;q=0.4\") =>\n *     { type: 'text',\n *       subtype: 'html', \n *       params: { level: '2', q: '0.4' } }\n *\n *   parseMediaValue(\"en-gb;q=0.8\", \"-\") =>\n *     { type: 'en',\n *       subtype: 'gb',\n *       params: { q: '0.8' } }\n *\n *   parseMediaValue(\"unicode-1-1;q=0.8\") =>\n *     { type: 'unicode-1-1',\n *       subtype: undefined,\n *       params: { q: '0.8' } }\n */\nfunction parseMediaValue(value, typeSeparator) {\n  typeSeparator = typeSeparator || '/';\n\n  var parts = value.split(/\\s*;\\s*/);\n  var mediaTypes = parts.shift().split(typeSeparator, 2);\n  var params = parts.reduce(function (memo, part) {\n    var nameValue = part.split('=', 2);\n    memo[nameValue[0]] = nameValue[1];\n    return memo;\n  }, {});\n\n  return {\n    type: mediaTypes[0],\n    subtype: mediaTypes[1],\n    params: params\n  };\n}\n\nmodule.exports = parseMediaValue;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/parseMediaValues.js":"var parseMediaValue = require('./parseMediaValue');\n\n/**\n * Parses a string containing multiple media values and returns an array\n * of objects containing data about each value. Such strings are used as\n * the values of the Accept* family of HTTP headers.\n */\nfunction parseMediaValues(value, typeSeparator) {\n  return value.split(/\\s*,\\s*/).map(function (mediaValue) {\n    return parseMediaValue(mediaValue, typeSeparator);\n  });\n}\n\nmodule.exports = parseMediaValues;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/qualityFactorForMediaValue.js":"/**\n * Returns the quality factor for the given media value object.\n */\nfunction qualityFactorForMediaValue(value) {\n  var qualityFactor = value.params && value.params.q;\n  return qualityFactor ? parseFloat(qualityFactor) : 1;\n}\n\nmodule.exports = qualityFactorForMediaValue;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/stringifyMediaValues.js":"var stringifyMediaValue = require('./stringifyMediaValue');\n\n/**\n * Creates a string from objects containing media values. Such a string may\n * be used as the value of the Accept* family of HTTP headers.\n */\nfunction stringifyMediaValues(values, typeSeparator) {\n  return values.map(function (mediaValue) {\n    return stringifyMediaValue(mediaValue, typeSeparator);\n  }).join(', ');\n}\n\nmodule.exports = stringifyMediaValues;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/stringifyMediaValue.js":"/**\n * Creates a string from an object containing a media value. This object may\n * have properties containing the type, subtype, and parameters.\n *\n *   stringifyMediaValue({ type: 'text', subtype: 'html', params: { level: '2', q: '0.4' } }) =>\n *     \"text/html;level=2;q=0.4\"\n *\n *   stringifyMediaValue({ type: 'en', subtype: 'gb', params: { q: '0.8' } }, \"-\") =>\n *     \"en-gb;q=0.8\"\n *\n *   stringifyMediaValue({ type: 'unicode-1-1', params: { q: '0.8' } }) =>\n *     \"unicode-1-1;q=0.8\"\n */\nfunction stringifyMediaValue(value, typeSeparator) {\n  typeSeparator = typeSeparator || '/';\n\n  var string = value.type || '*';\n\n  if (value.subtype)\n    string += typeSeparator + value.subtype;\n\n  if (value.params) {\n    var params = value.params;\n\n    for (var paramName in params) {\n      if (params.hasOwnProperty(paramName)) {\n        string += ';' + paramName;\n\n        if (params[paramName] != null)\n          string += '=' + params[paramName];\n      }\n    }\n  }\n\n  return string;\n}\n\nmodule.exports = stringifyMediaValue;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/stringifyMediaValueWithoutQualityFactor.js":"var stringifyMediaValue = require('./stringifyMediaValue');\n\nfunction cloneParamsWithoutQualityFactor(params) {\n  var clone = {};\n\n  for (var paramName in params)\n    if (params.hasOwnProperty(paramName) && paramName !== 'q')\n      clone[paramName] = params[paramName]; \n\n  return clone;\n}\n\n/**\n * Creates a string from an object containing a media value,\n * ignoring any \"q\" value parameters.\n */\nfunction stringifyMediaValueWithoutQualityFactor(value, typeSeparator) {\n  return stringifyMediaValue({\n    type: value.type,\n    subtype: value.subtype,\n    params: value.params && cloneParamsWithoutQualityFactor(value.params)\n  }, typeSeparator);\n}\n\nmodule.exports = stringifyMediaValueWithoutQualityFactor;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/acceptCharset.js":"var d = require('describe-property');\nvar AcceptCharset = require('../headers/AcceptCharset');\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given character set.\n     */\n    acceptsCharset: d(function (charset) {\n      return this.request.acceptsCharset(charset);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given character set.\n     */\n    acceptsCharset: d(function (charset) {\n      if (!this._acceptCharsetHeader)\n        this._acceptCharsetHeader = new AcceptCharset(this.headers['Accept-Charset']);\n\n      return this._acceptCharsetHeader.accepts(charset);\n    })\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/headers/AcceptCharset.js":"var parseMediaValue = require('../utils/parseMediaValue');\nvar parseMediaValues = require('../utils/parseMediaValues');\nvar qualityFactorForMediaValue = require('../utils/qualityFactorForMediaValue');\nvar stringifyMediaValues = require('../utils/stringifyMediaValues');\nvar Header = require('../Header');\n\nfunction byHighestPrecedence(a, b) {\n  // \"*\" gets least precedence, all others are equal\n  return a === '*' ? -1 : (b === '*' ? 1 : 0);\n}\n\n/**\n * Represents an HTTP Accept-Charset header and provides several methods\n * for determining acceptable content character sets.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2\n */\nclass AcceptCharset extends Header {\n\n  constructor(value) {\n    super('Accept-Charset', value);\n  }\n\n  /**\n   * Returns the value of this header as a string.\n   */\n  get value() {\n    return stringifyMediaValues(this._mediaValues) || '';\n  }\n\n  set value(value) {\n    this._mediaValues = value ? parseMediaValues(value) : [];\n  }\n\n  /**\n   * Returns true if the given charset is acceptable.\n   */\n  accepts(charset) {\n    return this.qualityFactorForCharset(charset) !== 0;\n  }\n\n  /**\n   * Returns the quality factor for the given charset.\n   */\n  qualityFactorForCharset(charset) {\n    var values = this._mediaValues;\n\n    var givenValue = parseMediaValue(charset);\n    var matchingValues = values.filter(function (value) {\n      if (value.type === '*')\n        return true;\n\n      return value.type === givenValue.type;\n    }).sort(byHighestPrecedence);\n\n    // From RFC 2616:\n    // The special value \"*\", if present in the Accept-Charset field, matches every character\n    // set (including ISO-8859-1) which is not mentioned elsewhere in the Accept-Charset field.\n    // If no \"*\" is present in an Accept-Charset field, then all character sets not explicitly\n    // mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of\n    // 1 if not explicitly mentioned.\n    if (givenValue.type === 'iso-8859-1') {\n      if (matchingValues.length && matchingValues[0].type === 'iso-8859-1')\n        return qualityFactorForMediaValue(matchingValues[0]);\n\n      return 1;\n    }\n\n    if (!matchingValues.length)\n      return 0;\n\n    return qualityFactorForMediaValue(matchingValues[0]);\n  }\n\n}\n\nmodule.exports = AcceptCharset;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/acceptEncoding.js":"var d = require('describe-property');\nvar AcceptEncoding = require('../headers/AcceptEncoding');\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given content encoding.\n     */\n    acceptsEncoding: d(function (encoding) {\n      return this.request.acceptsEncoding(encoding);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given content encoding.\n     */\n    acceptsEncoding: d(function (encoding) {\n      if (!this._acceptEncodingHeader)\n        this._acceptEncodingHeader = new AcceptEncoding(this.headers['Accept-Encoding']);\n\n      return this._acceptEncodingHeader.accepts(encoding);\n    })\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/headers/AcceptEncoding.js":"var parseMediaValue = require('../utils/parseMediaValue');\nvar parseMediaValues = require('../utils/parseMediaValues');\nvar qualityFactorForMediaValue = require('../utils/qualityFactorForMediaValue');\nvar stringifyMediaValues = require('../utils/stringifyMediaValues');\nvar Header = require('../Header');\n\nfunction byHighestPrecedence(a, b) {\n  // \"*\" gets least precedence, all others are equal\n  return a === '*' ? -1 : (b === '*' ? 1 : 0);\n}\n\n/**\n * Represents an HTTP Accept-Encoding header and provides several methods\n * for determining acceptable content encodings.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n */\nclass AcceptEncoding extends Header {\n\n  constructor(value) {\n    super('Accept-Encoding', value);\n  }\n\n  /**\n   * Returns the value of this header as a string.\n   */\n  get value() {\n    return stringifyMediaValues(this._mediaValues) || '';\n  }\n\n  set value(value) {\n    this._mediaValues = value ? parseMediaValues(value) : [];\n  }\n\n  /**\n   * Returns true if the given encoding is acceptable.\n   */\n  accepts(encoding) {\n    return this.qualityFactorForEncoding(encoding) !== 0;\n  }\n\n  /**\n   * Returns the quality factor for the given encoding.\n   */\n  qualityFactorForEncoding(encoding) {\n    var values = this._mediaValues;\n\n    var givenValue = parseMediaValue(encoding);\n    var matchingValues = values.filter(function (value) {\n      if (value.type === '*')\n        return true;\n\n      return value.type === givenValue.type;\n    }).sort(byHighestPrecedence);\n\n    // From RFC 2616:\n    // The \"identity\" content-coding is always acceptable, unless\n    // specifically refused because the Accept-Encoding field includes\n    // \"identity;q=0\", or because the field includes \"*;q=0\" and does\n    // not explicitly include the \"identity\" content-coding. If the\n    // Accept-Encoding field-value is empty, then only the \"identity\"\n    // encoding is acceptable.\n    if (givenValue.type === 'identity') {\n      if (matchingValues.length && matchingValues[0].type === 'identity')\n        return qualityFactorForMediaValue(matchingValues[0]);\n\n      return 1;\n    }\n\n    if (!matchingValues.length)\n      return 0;\n\n    return qualityFactorForMediaValue(matchingValues[0]);\n  }\n\n}\n\nmodule.exports = AcceptEncoding;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/acceptLanguage.js":"var d = require('describe-property');\nvar AcceptLanguage = require('../headers/AcceptLanguage');\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * Returns true if the request indicates that the client accepts\n     * the given content language.\n     */\n    acceptsLanguage: d(function (language) {\n      return this.request.acceptsLanguage(language);\n    })\n\n  });\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Returns true if the client accepts the given content language.\n     */\n    acceptsLanguage: d(function (language) {\n      if (!this._acceptLanguageHeader)\n        this._acceptLanguageHeader = new AcceptLanguage(this.headers['Accept-Language']);\n\n      return this._acceptLanguageHeader.accepts(language);\n    })\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/headers/AcceptLanguage.js":"var parseMediaValue = require('../utils/parseMediaValue');\nvar parseMediaValues = require('../utils/parseMediaValues');\nvar qualityFactorForMediaValue = require('../utils/qualityFactorForMediaValue');\nvar stringifyMediaValues = require('../utils/stringifyMediaValues');\nvar stringifyMediaValueWithoutQualityFactor = require('../utils/stringifyMediaValueWithoutQualityFactor');\nvar Header = require('../Header');\n\nfunction byHighestPrecedence(a, b) {\n  // \"*\" gets least precedence, all others are compared by specificity\n  return a === '*' ? -1 : (b === '*' ? 1 : byMostSpecific(a, b));\n}\n\nfunction byMostSpecific(a, b) {\n  return stringifyMediaValueWithoutQualityFactor(b).length - stringifyMediaValueWithoutQualityFactor(a).length;\n}\n\n/**\n * Represents an HTTP Accept-Language header and provides several methods\n * for determining acceptable content languages.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n */\nclass AcceptLanguage extends Header {\n\n  constructor(value) {\n    super('Accept-Language', value);\n  }\n\n  /**\n   * Returns the value of this header as a string.\n   */\n  get value() {\n    return stringifyMediaValues(this._mediaValues, '-') || '';\n  }\n\n  set value(value) {\n    this._mediaValues = value ? parseMediaValues(value, '-') : [];\n  }\n\n  /**\n   * Returns true if the given language is acceptable.\n   */\n  accepts(language) {\n    return this.qualityFactorForLanguage(language) !== 0;\n  }\n\n  /**\n   * Returns the quality factor for the given language.\n   */\n  qualityFactorForLanguage(language) {\n    var values = this._mediaValues;\n\n    if (!values.length)\n      return 1;\n\n    var givenValue = parseMediaValue(language, '-');\n    var matchingValues = values.filter(function (value) {\n      if (value.type === '*')\n        return true;\n\n      if (value.subtype && value.subtype !== givenValue.subtype)\n        return false;\n\n      return value.type === givenValue.type;\n    }).sort(byHighestPrecedence);\n\n    if (!matchingValues.length)\n      return 0;\n\n    return qualityFactorForMediaValue(matchingValues[0]);\n  }\n\n}\n\nmodule.exports = AcceptLanguage;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/client.js":"var objectAssign = require('object-assign');\nvar sendRequest = require('../utils/sendRequest');\nvar Location = require('../Location');\n\nfunction defaultApp(conn) {\n  return sendRequest(conn, conn.location);\n}\n\nmodule.exports = function (mach) {\n  mach.call = require('../utils/callApp');\n\n  [ 'DELETE',\n    'GET',\n    'HEAD',\n    'OPTIONS',\n    'POST',\n    'PUT',\n    'TRACE'\n  ].forEach(function (method) {\n    var property = method.toLowerCase();\n\n    mach[property] = function (app, options, modifier) {\n      if (typeof app !== 'function') {\n        modifier = options;\n\n        if (typeof app === 'string') { // get(url, modifier)\n          options = { url: app };\n        } else if (app instanceof Location) { // get(location, modifier)\n          options = { location: app };\n        } else { // get(options, modifier)\n          options = objectAssign({}, app || {});\n        }\n\n        app = defaultApp;\n      } else if (typeof options === 'string') { // get(app, url, modifier)\n        options = { url: options };\n      } else if (options instanceof Location) { // get(app, location, modifier)\n        options = { location: options };\n      } else if (typeof options !== 'object') { // get(app, modifier)\n        modifier = options;\n        options = {};\n      } else { // get(app, options, modifier)\n        options = objectAssign({}, options || {});\n      }\n\n      options.method = method;\n\n      return mach.call(app, options, modifier);\n    };\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/sendRequest.js":"var http = require('http');\nvar https = require('https');\nvar AbortablePromise = require('./AbortablePromise');\n\nfunction sendRequest(conn, location) {\n  var transport = location.protocol === 'https:' ? https : http;\n\n  return new AbortablePromise(function (resolve, reject, onAbort) {\n    var nodeRequest = transport.request({\n      method: conn.method,\n      protocol: location.protocol,\n      auth: location.auth,\n      hostname: location.hostname,\n      port: location.port,\n      path: location.path,\n      headers: conn.request.headers\n    });\n\n    nodeRequest.on('response', function (nodeResponse) {\n      conn.status = nodeResponse.statusCode;\n      conn.response.headers = nodeResponse.headers;\n      conn.response.content = nodeResponse;\n      resolve(conn);\n    });\n\n    nodeRequest.on('error', reject);\n\n    onAbort(function () {\n      nodeRequest.abort();\n      resolve();\n    });\n\n    conn.request.content.pipe(nodeRequest);\n  });\n}\n\nmodule.exports = sendRequest;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/AbortablePromise.js":"var Promise = require('./Promise');\n\nfunction makeAbortable(promise, abort) {\n  promise.abort = abort;\n\n  // Hijack promise.then so it returns an abortable promise.\n  var _then = promise.then;\n  promise.then = function () {\n    return makeAbortable(_then.apply(promise, arguments), abort);\n  };\n\n  return promise;\n}\n\n/**\n * A Promise class with an abort() method that calls the onAbort function\n * provided by the resolver.\n *\n * Example:\n *\n *   var promise = new AbortablePromise(function (resolve, reject, onAbort) {\n *     // Use resolve & reject as you normally would.\n *     var request = makeRequest( ... , function (error, response) {\n *       if (error) {\n *         reject(error);\n *       } else {\n *         resolve(response);\n *       }\n *     });\n *   \n *     // Use onAbort to register a promise.abort() function. It is the\n *     // responsibility of this function to abort the execution of the\n *     // promise and resolve/reject as needed.\n *     onAbort(function () {\n *       request.abort();\n *       reject(new Error('Request was aborted'));\n *     });\n *   });\n *\n *   promise.abort(); // Calls the onAbort handler.\n */\nfunction AbortablePromise(resolver) {\n  if (typeof resolver !== 'function')\n    throw new Error('AbortablePromise needs a resolver function');\n\n  var abort;\n  var promise = new Promise(function (resolve, reject) {\n    var aborter;\n\n    abort = function () {\n      if (aborter == null)\n        return;\n\n      var fn = aborter;\n      aborter = null;\n\n      try {\n        return fn.apply(this, arguments);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    resolver(function (child) {\n      if (child && typeof child.abort === 'function') {\n        aborter = child.abort;\n      } else {\n        aborter = null;\n      }\n\n      resolve.apply(this, arguments);\n    }, function () {\n      aborter = null;\n      reject.apply(this, arguments);\n    }, function (fn) {\n      if (typeof fn !== 'function')\n        throw new Error('onAbort needs a function');\n\n      aborter = fn;\n    });\n  });\n\n  return makeAbortable(promise, abort);\n}\n\nmodule.exports = AbortablePromise;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/middleware.js":"var middleware = require('../middleware');\n\nmodule.exports = function (mach) {\n  for (var property in middleware)\n    if (middleware.hasOwnProperty(property))\n      mach[property] = middleware[property];\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/index.js":"module.exports = {\n  basicAuth       : require('./basicAuth'),\n  catch           : require('./catch'),\n  charset         : require('./charset'),\n  contentType     : require('./contentType'),\n  favicon         : require('./favicon'),\n  file            : require('./file'),\n  gzip            : require('./gzip'),\n  logger          : require('./logger'),\n  mapper          : require('./mapper'),\n  methodOverride  : require('./methodOverride'),\n  modified        : require('./modified'),\n  params          : require('./params'),\n  proxy           : require('./proxy'),\n  rewrite         : require('./rewrite'),\n  router          : require('./router'),\n  session         : require('./session'),\n  stack           : require('./stack'),\n  token           : require('./token')\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/basicAuth.js":"var mach = require('../index');\nvar Promise = require('../utils/Promise');\n\nmach.extend(\n  require('../extensions/server')\n);\n\n/**\n * A middleware that performs basic auth on the incoming request before passing\n * it downstream.\n *\n * The `validate` argument must be a function that accepts two arguments: the\n * username and password given in the request. It must return the username to\n * use for the request (or simply `true` to indicate the given username is\n * valid) or a promise for such a value. The validated username is stored in the\n * `remoteUser` request variable.\n *\n * When authorization fails, the client automatically receives a 401 Unauthorized\n * response with the appropriate challenge in the WWW-Authenticate header.\n *\n * Example:\n *\n *   mach.basicAuth(app, function (user, pass) {\n *     // Return a boolean value to indicate the given credentials are valid.\n *     return (user === 'admin' && pass === 'secret');\n *   });\n *\n *   mach.basicAuth(app, function (user, pass) {\n *     // Return a promise for the actual username to use.\n *     return query('SELECT username FROM users WHERE handle=? AND password=?', user, pass);\n *   });\n */\nfunction basicAuth(app, options) {\n  options = options || {};\n\n  if (typeof options === 'function')\n    options = { validate: options };\n\n  if (typeof options.validate !== 'function')\n    throw new Error('mach.basicAuth needs a validation function');\n\n  var realm = options.realm || 'Authorization Required';\n\n  return function (conn) {\n    if (conn.remoteUser)\n      return conn.call(app); // Don't overwrite existing remoteUser.\n\n    var credentials = conn.auth.split(':', 2);\n    var username = credentials[0], password = credentials[1];\n\n    return Promise.resolve(options.validate(username, password)).then(function (user) {\n      if (user) {\n        conn.remoteUser = (user === true) ? username : user;\n        return conn.call(app);\n      }\n\n      conn.response.headers['WWW-Authenticate'] = 'Basic realm=\"' + realm + '\"';\n      conn.text(401, 'Not Authorized');\n    });\n  };\n}\n\nmodule.exports = basicAuth;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/server.js":"var fs = require('fs');\nvar d = require('describe-property');\nvar objectAssign = require('object-assign');\nvar getMimeType = require('../utils/getMimeType');\nvar filterProperties = require('../utils/filterProperties');\nvar stringifyCookie = require('../utils/stringifyCookie');\nvar saveToDisk = require('../utils/saveToDisk');\n\nmodule.exports = function (mach) {\n  mach.bind = require('../utils/bindApp');\n  mach.createConnection = require('../utils/createConnection');\n  mach.serve = require('../utils/serveApp');\n\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * True if the request uses XMLHttpRequest, false otherwise.\n     */\n    isXHR: d.gs(function () {\n      return this.request.headers['X-Requested-With'] === 'XMLHttpRequest';\n    }),\n\n    /**\n     * A high-level method that returns a promise for an object that is the\n     * union of parameters contained in the request body and query string.\n     *\n     * The paramTypes argument may be used to filter parameters. It functions\n     * like a whitelist of acceptable parameters and increases the security of\n     * your app by not returning any parameters that you do not specify.\n     *\n     *   // This function parses a list of comma-separated values in\n     *   // a request parameter into an array.\n     *   function parseList(value) {\n     *     return value.split(',');\n     *   }\n     *\n     *   function app(conn) {\n     *     return conn.getParams({\n     *       name: String,\n     *       age: Number,\n     *       hobbies: parseList\n     *     }).then(function (params) {\n     *       // params.name will be a string, params.age a number, and\n     *       // params.hobbies an array if they were provided in the\n     *       // request. params won't contain any other properties.\n     *     });\n     *   }\n     *\n     * Of course, paramTypes may be omitted entirely to get a hash of all parameters.\n     * \n     * The maxLength argument is passed directly to the request's parseContent method.\n     *\n     *   var maxUploadLimit = Math.pow(2, 20); // 1 mb\n     *\n     *   function app(conn) {\n     *     return conn.getParams(maxUploadLimit).then(function (params) {\n     *       // params is the union of query and request content params\n     *     });\n     *   }\n     *\n     * Note: Content parameters take precedence over query parameters with the same name.\n     */\n    getParams: d(function (paramTypes, maxLength) {\n      if (typeof paramTypes !== 'object') {\n        maxLength = paramTypes;\n        paramTypes = null;\n      }\n\n      var request = this.request;\n      var queryParams = objectAssign({}, this.query);\n\n      return request.parseContent(maxLength).then(function (contentParams) {\n        // Content params take precedence over query params.\n        var params = objectAssign(queryParams, contentParams);\n        return paramTypes ? filterProperties(params, paramTypes) : params;\n      });\n    }),\n\n    /**\n     * Redirects the client to the given location. If status is not\n     * given, it defaults to 302 Found.\n     */\n    redirect: d(function (status, location) {\n      if (typeof status !== 'number') {\n        location = status;\n        status = 302;\n      }\n\n      this.status = status;\n      this.response.headers['Location'] = location;\n    }),\n\n    /**\n     * Redirects the client back to the URL they just came from, or\n     * to the given location if it isn't known.\n     */\n    back: d(function (location) {\n      this.redirect(this.request.headers['Referer'] || location || '/');\n    }),\n\n    /**\n     * A quick way to write the status and/or content to the response.\n     *\n     * Examples:\n     *\n     *   conn.send(404);\n     *   conn.send(404, 'Not Found');\n     *   conn.send('Hello world');\n     *   conn.send(fs.createReadStream('welcome.txt'));\n     */\n    send: d(function (status, content) {\n      if (typeof status === 'number') {\n        this.status = status;\n      } else {\n        content = status;\n      }\n\n      if (content != null)\n        this.response.content = content;\n    }),\n\n    /**\n     * Sends the given text in a text/plain response.\n     */\n    text: d(function (status, text) {\n      this.response.contentType = 'text/plain';\n      this.send(status, text);\n    }),\n\n    /**\n     * Sends the given HTML in a text/html response.\n     */\n    html: d(function (status, html) {\n      this.response.contentType = 'text/html';\n      this.send(status, html);\n    }),\n\n    /**\n     * Sends the given JSON in an application/json response.\n     */\n    json: d(function (status, json) {\n      this.response.contentType = 'application/json';\n\n      if (typeof status === 'number') {\n        this.status = status;\n      } else {\n        json = status;\n      }\n\n      if (json != null)\n        this.response.content = typeof json === 'string' ? json : JSON.stringify(json);\n    }),\n\n    /**\n     * Sends a file to the client with the given options. The following\n     * options are available:\n     *\n     * - content/path   The raw file content as a string, Buffer, stream, or\n     *                  path to a file on disk\n     * - type           The Content-Type of the file. Defaults to a guess based\n     *                  on the file extension when a file path is given\n     * - length/size    The Content-Length of the file, if it's known. Defaults\n     *                  to the size of the file when a file path is given\n     *\n     * Examples:\n     *\n     *   response.file('path/to/file.txt');\n     *   response.file(200, 'path/to/file.txt');\n     */\n    file: d(function (status, options) {\n      if (typeof status === 'number') {\n        this.status = status;\n      } else {\n        options = status;\n      }\n\n      var response = this.response;\n\n      if (typeof options === 'string')\n        options = { path: options };\n\n      if (options.content) {\n        response.content = options.content;\n      } else if (typeof options.path === 'string') {\n        response.content = fs.createReadStream(options.path);\n      } else {\n        throw new Error('Missing file content/path');\n      }\n\n      if (options.type || options.path)\n        response.headers['Content-Type'] = options.type || getMimeType(options.path);\n\n      if (options.length || options.size) {\n        response.headers['Content-Length'] = options.length || options.size;\n      } else if (typeof options.path === 'string') {\n        response.headers['Content-Length'] = fs.statSync(options.path).size;\n      }\n    })\n\n  });\n\n  mach.extend(require('./multipart'));\n\n  var _handlePart = mach.Message.prototype.handlePart;\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * Sets a cookie with the given name and options.\n     */\n    setCookie: d(function (name, options) {\n      this.addHeader('Set-Cookie', stringifyCookie(name, options));\n    }),\n\n    /**\n     * Override the multipart extension's Message#handlePart to enable\n     * streaming file uploads to disk when parsing multipart messages.\n     */\n    handlePart: d(function (part) {\n      return part.filename ? saveToDisk(part, 'MachUpload-') : _handlePart.apply(this, arguments);\n    })\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/getMimeType.js":"var MimeTypes = require('../MimeTypes');\nvar ExtTypes = {};\n\nObject.keys(MimeTypes).forEach(function (type) {\n  MimeTypes[type].forEach(function (ext) {\n    ExtTypes[ext] = type;\n  });\n});\n\nvar DEFAULT_TYPE = 'application/octet-stream';\nvar EXT_MATCHER = /\\.(\\w+)$/;\n\nfunction getMimeType(file, defaultType) {\n  var match = file.match(EXT_MATCHER);\n  return (match && ExtTypes[match[1]]) || defaultType || DEFAULT_TYPE;\n}\n\nmodule.exports = getMimeType;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/MimeTypes.js":"/**\n * A map of MIME types to file extensions that correspond to that type.\n */\nmodule.exports = {\n  \"text/html\"                           : [ \"html\", \"htm\", \"shtml\" ],\n  \"text/css\"                            : [ \"css\" ],\n  \"text/xml\"                            : [ \"xml\" ],\n  \"image/gif\"                           : [ \"gif\" ],\n  \"image/jpeg\"                          : [ \"jpeg\", \"jpg\" ],\n  \"application/javascript\"              : [ \"js\" ],\n  \"application/atom+xml\"                : [ \"atom\" ],\n  \"application/rss+xml\"                 : [ \"rss\" ],\n\n  \"text/mathml\"                         : [ \"mml\" ],\n  \"text/plain\"                          : [ \"txt\" ],\n  \"text/vnd.sun.j2me.app-descriptor\"    : [ \"jad\" ],\n  \"text/vnd.wap.wml\"                    : [ \"wml\" ],\n  \"text/x-component\"                    : [ \"htc\" ],\n\n  \"image/png\"                           : [ \"png\" ],\n  \"image/tiff\"                          : [ \"tif\", \"tiff\" ],\n  \"image/vnd.wap.wbmp\"                  : [ \"wbmp\" ],\n  \"image/x-icon\"                        : [ \"ico\" ],\n  \"image/x-jng\"                         : [ \"jng\" ],\n  \"image/x-ms-bmp\"                      : [ \"bmp\" ],\n  \"image/svg+xml\"                       : [ \"svg\", \"svgz\" ],\n  \"image/webp\"                          : [ \"webp\" ],\n\n  \"application/font-woff\"               : [ \"woff\" ],\n  \"application/java-archive\"            : [ \"jar\", \"war\", \"ear\" ],\n  \"application/json\"                    : [ \"json\" ],\n  \"application/mac-binhex40\"            : [ \"hqx\" ],\n  \"application/msword\"                  : [ \"doc\" ],\n  \"application/pdf\"                     : [ \"pdf\" ],\n  \"application/postscript\"              : [ \"ps\", \"eps\", \"ai\" ],\n  \"application/rtf\"                     : [ \"rtf\" ],\n  \"application/vnd.apple.mpegurl\"       : [ \"m3u8\" ],\n  \"application/vnd.ms-excel\"            : [ \"xls\" ],\n  \"application/vnd.ms-fontobject\"       : [ \"eot\" ],\n  \"application/vnd.ms-powerpoint\"       : [ \"ppt\" ],\n  \"application/vnd.wap.wmlc\"            : [ \"wmlc\" ],\n  \"application/vnd.google-earth.kml+xml\": [ \"kml\" ],\n  \"application/vnd.google-earth.kmz\"    : [ \"kmz\" ],\n  \"application/x-7z-compressed\"         : [ \"7z\" ],\n  \"application/x-cocoa\"                 : [ \"cco\" ],\n  \"application/x-java-archive-diff\"     : [ \"jardiff\" ],\n  \"application/x-java-jnlp-file\"        : [ \"jnlp\" ],\n  \"application/x-makeself\"              : [ \"run\" ],\n  \"application/x-perl\"                  : [ \"pl\", \"pm\" ],\n  \"application/x-pilot\"                 : [ \"prc\", \"pdb\" ],\n  \"application/x-rar-compressed\"        : [ \"rar\" ],\n  \"application/x-redhat-package-manager\": [ \"rpm\" ],\n  \"application/x-sea\"                   : [ \"sea\" ],\n  \"application/x-shockwave-flash\"       : [ \"swf\" ],\n  \"application/x-stuffit\"               : [ \"sit\" ],\n  \"application/x-tcl\"                   : [ \"tcl\", \"tk\" ],\n  \"application/x-x509-ca-cert\"          : [ \"der\", \"pem\", \"crt\" ],\n  \"application/x-xpinstall\"             : [ \"xpi\" ],\n  \"application/xhtml+xml\"               : [ \"xhtml\" ],\n  \"application/xspf+xml\"                : [ \"xspf\" ],\n  \"application/zip\"                     : [ \"zip\" ],\n\n  \"application/octet-stream\"            : [ \"bin\", \"exe\", \"dll\", \"deb\", \"dmg\", \"iso\", \"img\", \"msi\", \"msp\", \"msm\" ],\n\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"  : [ \"docx\" ],\n  \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"        : [ \"xlsx\" ],\n  \"application/vnd.openxmlformats-officedocument.presentationml.presentation\": [ \"pptx\" ],\n\n  \"audio/midi\"                          : [ \"mid\", \"midi\", \"kar\" ],\n  \"audio/mpeg\"                          : [ \"mp3\" ],\n  \"audio/ogg\"                           : [ \"ogg\" ],\n  \"audio/x-m4a\"                         : [ \"m4a\" ],\n  \"audio/x-realaudio\"                   : [ \"ra\" ],\n\n  \"video/3gpp\"                          : [ \"3gpp\", \"3gp\" ],\n  \"video/mp2t\"                          : [ \"ts\" ],\n  \"video/mp4\"                           : [ \"mp4\" ],\n  \"video/mpeg\"                          : [ \"mpeg\", \"mpg\" ],\n  \"video/quicktime\"                     : [ \"mov\" ],\n  \"video/webm\"                          : [ \"webm\" ],\n  \"video/x-flv\"                         : [ \"flv\" ],\n  \"video/x-m4v\"                         : [ \"m4v\" ],\n  \"video/x-mng\"                         : [ \"mng\" ],\n  \"video/x-ms-asf\"                      : [ \"asx\", \"asf\" ],\n  \"video/x-ms-wmv\"                      : [ \"wmv\" ],\n  \"video/x-msvideo\"                     : [ \"avi\" ]\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/filterProperties.js":"/**\n * Returns a shallow copy of the properties of the given object,\n * filtered by the functions in propertyTypes.\n */\nfunction filterProperties(object, propertyTypes) {\n  var properties = {};\n\n  var type, value;\n  for (var property in object) {\n    type = propertyTypes[property];\n\n    if (typeof type === 'function' && object.hasOwnProperty(property)) {\n      value = type(object[property]);\n\n      if (value !== undefined)\n        properties[property] = value;\n    }\n  }\n\n  return properties;\n}\n\nmodule.exports = filterProperties;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/stringifyCookie.js":"/**\n * Creates a cookie string using the given options, which may be any of\n * the following:\n *\n * - value\n * - domain\n * - path\n * - expires\n * - secure\n * - httpOnly or HttpOnly\n */\nfunction stringifyCookie(name, options) {\n  options = options || {};\n\n  if (typeof options === 'string')\n    options = { value: options };\n\n  var cookie = encodeURIComponent(name) + '=' + encodeURIComponent(options.value || '');\n\n  if (options.domain)\n    cookie += '; domain=' + options.domain;\n\n  if (options.path)\n    cookie += '; path=' + options.path;\n\n  if (options.expires)\n    cookie += '; expires=' + (options.expires instanceof Date) ? options.expires.toUTCString() : options.expires;\n\n  if (options.secure)\n    cookie += '; secure';\n\n  if (options.httpOnly || options.HttpOnly)\n    cookie += '; HttpOnly';\n\n  return cookie;\n}\n\nmodule.exports = stringifyCookie;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/saveToDisk.js":"var fs = require('fs');\nvar File = require('./File');\nvar Promise = require('./Promise');\nvar makeTemporaryPath = require('./makeTemporaryPath');\n\nfunction saveToDisk(message, filePrefix) {\n  return new Promise(function (resolve, reject) {\n    var content = message.content;\n    var path = makeTemporaryPath(filePrefix);\n    var stream = fs.createWriteStream(path);\n    var size = 0;\n\n    content.on('error', reject);\n\n    content.on('data', function (chunk) {\n      size += chunk.length;\n      stream.write(chunk);\n    });\n\n    content.on('end', function () {\n      stream.end(function () {\n        resolve(\n          new File({\n            path: path,\n            name: message.filename,\n            type: message.mediaType,\n            size: size\n          })\n        );\n      });\n    });\n\n    if (typeof content.resume === 'function')\n      content.resume();\n  });\n}\n\nmodule.exports = saveToDisk;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/File.js":"function File(properties) {\n  this.path = properties.path;\n  this.name = properties.name;\n  this.type = properties.type;\n  this.size = properties.size;\n}\n\nmodule.exports = File;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/makeTemporaryPath.js":"var path = require('path');\nvar TMP_DIR = require('os').tmpDir();\n\nfunction makeTemporaryPath(prefix) {\n  prefix = prefix || '';\n\n  var random = (Math.random() * 0x100000000 + 1).toString(36);\n  var now = new Date();\n  var date = '' + now.getYear() + now.getMonth() + now.getDate();\n  var name = [ prefix, date, '-', process.pid, '-', random ].join('');\n\n  return path.join(TMP_DIR, name);\n}\n\nmodule.exports = makeTemporaryPath;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/bindApp.js":"var createRequestHandler = require('./createRequestHandler');\n\n/**\n * Binds the given app to the \"request\" event of the given node HTTP server\n * so that it is called whenever the server receives a new request. Returns\n * the request handler function.\n */\nfunction bindApp(app, nodeServer) {\n  var requestHandler = createRequestHandler(app);\n  nodeServer.on('request', requestHandler);\n  return requestHandler;\n}\n\nmodule.exports = bindApp;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/createRequestHandler.js":"/* jshint -W058 */\nvar createConnection = require('./createConnection');\n\n/**\n * HTTP status codes that don't have entities.\n */\nvar STATUS_WITHOUT_CONTENT = {\n  100: true,\n  101: true,\n  204: true,\n  304: true\n};\n\n/**\n * Binds the given app to the \"request\" event of the given node HTTP server\n * so that it is called whenever the server receives a new request.\n *\n * Returns the request handler function.\n */\nfunction createRequestHandler(app) {\n  return function (nodeRequest, nodeResponse) {\n    var conn = createConnection(nodeRequest);\n\n    conn.call(app).then(function () {\n      var isHead = conn.method === 'HEAD';\n      var isEmpty = isHead || STATUS_WITHOUT_CONTENT[conn.status] === true;\n      var headers = conn.response.headers;\n      var content = conn.response.content;\n\n      if (isEmpty && !isHead)\n        headers['Content-Length'] = 0;\n\n      if (!headers['Date'])\n        headers['Date'] = (new Date).toUTCString();\n\n      nodeResponse.writeHead(conn.status, headers);\n\n      if (isEmpty) {\n        nodeResponse.end();\n\n        if (typeof content.destroy === 'function')\n          content.destroy();\n      } else {\n        content.pipe(nodeResponse);\n      }\n    }, function (error) {\n      conn.onError(error);\n      nodeResponse.writeHead(500, { 'Content-Type': 'text/plain' });\n      nodeResponse.end('Internal Server Error');\n    });\n  };\n}\n\nmodule.exports = createRequestHandler;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/createConnection.js":"var Connection = require('../Connection');\nvar Location = require('../Location');\n\n/**\n * Standard ports for HTTP protocols.\n */\nvar STANDARD_PORTS = {\n  'http:': '80',\n  'https:': '443'\n};\n\nfunction ensureTrailingColon(string) {\n  return string[string.length - 1] === ':' ? string : string + ':';\n}\n\n/**\n * Creates a new Location object that is reverse-proxy aware.\n */\nfunction createLocation(nodeRequest) {\n  var headers = nodeRequest.headers;\n\n  var protocol;\n  if (process.env.HTTPS === 'on' || headers['x-forwarded-ssl'] === 'on' || headers['font-end-https'] === 'on') {\n    protocol = 'https:';\n  } else if (headers['x-url-scheme']) {\n    protocol = ensureTrailingColon(headers['x-url-scheme']);\n  } else if (headers['x-forwarded-protocol']) {\n    protocol = ensureTrailingColon(headers['x-forwarded-protocol'].split(',')[0]);\n  } else if (headers['x-forwarded-proto']) {\n    protocol = ensureTrailingColon(headers['x-forwarded-proto'].split(',')[0]);\n  } else {\n    protocol = 'http:';\n  }\n\n  var host;\n  if (headers['x-forwarded-host']) {\n    var hosts = headers['x-forwarded-host'].split(/,\\s?/);\n    host = hosts[hosts.length - 1];\n  } else if (headers['host']) {\n    host = headers['host'];\n  } else if (process.env.SERVER_NAME) {\n    host = process.env.SERVER_NAME;\n  }\n\n  var hostParts = host.split(':', 2);\n  var hostname = hostParts[0];\n  var port = hostParts[1] || headers['x-forwarded-port'];\n\n  if (port == null) {\n    if (headers['x-forwarded-host']) {\n      port = STANDARD_PORTS[protocol];\n    } else if (headers['x-forwarded-proto']) {\n      port = STANDARD_PORTS[headers['x-forwarded-proto'].split(',')[0]];\n    }\n  }\n\n  var path = nodeRequest.url;\n\n  return new Location({\n    protocol: protocol,\n    hostname: hostname,\n    port: port,\n    path: path\n  });\n}\n\n/**\n * Creates a mach.Connection from the given node.js HTTP request and\n * server (optional) objects. This is a low-level method that is not\n * generally needed by application-level code.\n */\nfunction createConnection(nodeRequest) {\n  var conn = new Connection({\n    version: nodeRequest.httpVersion,\n    method: nodeRequest.method,\n    location: createLocation(nodeRequest),\n    headers: nodeRequest.headers,\n    content: nodeRequest,\n    remoteHost: nodeRequest.connection.remoteAddress,\n    remotePort: nodeRequest.connection.remotePort\n  });\n\n  nodeRequest.on('close', function () {\n    conn.onClose();\n  });\n\n  return conn;\n}\n\nmodule.exports = createConnection;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/serveApp.js":"var http = require('http');\nvar https = require('https');\nvar bindApp = require('./bindApp');\n\n/**\n * The default port that node servers bind to.\n */\nvar DEFAULT_PORT = 5000;\n\n/**\n * Creates and starts a node HTTP server that serves the given app.\n *\n * Options may be any of the following:\n *\n * - host     The host name to accept connections on. Defaults to INADDR_ANY\n * - port     The port to listen on. Defaults to 5000\n * - socket   Unix socket file to listen on (trumps host/port)\n * - quiet    Set true to prevent the server from writing startup/shutdown\n *            messages to the console. Defaults to false\n * - timeout  The timeout to use when gracefully shutting down servers when\n *            SIGINT or SIGTERM are received. If a server doesn't close within\n *            this time (probably because it has open persistent connections)\n *            it is forecefully stopped when the process exits. Defaults to 100,\n *            meaning that servers forcefully shutdown after 100ms\n * - key      Private key to use for SSL (HTTPS only)\n * - cert     Public X509 certificate to use (HTTPS only)\n *\n * Note: When setting the timeout, be careful not to exceed any hard timeouts\n * specified by your PaaS. For example, Heroku's dyno manager will not permit\n * a timeout longer than ten seconds. See\n * https://devcenter.heroku.com/articles/dynos#graceful-shutdown-with-sigterm\n *\n * Returns the node HTTP server instance.\n */\nfunction serveApp(app, options) {\n  options = options || {};\n\n  if (typeof options === 'number') {\n    options = { port: options };\n  } else if (typeof options === 'string') {\n    options = { socket: options };\n  }\n\n  var nodeServer;\n  if (options.key && options.cert) {\n    nodeServer = https.createServer({ key: options.key, cert: options.cert });\n  } else {\n    nodeServer = http.createServer();\n  }\n\n  function shutdown() {\n    if (!options.quiet)\n      console.log('>> Shutting down...');\n\n    // Force the process to exit if the server doesn't\n    // close all connections within the given timeout.\n    var timer = setTimeout(function () {\n      if (!options.quiet)\n        console.log('>> Exiting');\n\n      process.exit(0);\n    }, options.timeout || 100);\n\n    // Don't let this timer keep the event loop running.\n    timer.unref();\n\n    nodeServer.close();\n  }\n\n  nodeServer.once('listening', function () {\n    bindApp(app, nodeServer);\n\n    process.once('SIGINT', shutdown);\n    process.once('SIGTERM', shutdown);\n\n    if (!options.quiet) {\n      var address = nodeServer.address();\n      var message = '>> mach web server started on node ' + process.versions.node + '\\n';\n\n      if (typeof address === 'string') {\n        message += '>> Listening on ' + address;\n      } else {\n        message += '>> Listening on ' + address.address;\n\n        if (address.port)\n          message += ':' + address.port;\n      }\n\n      message += ', use CTRL+C to stop';\n\n      console.log(message);\n    }\n  });\n\n  if (options.socket) {\n    nodeServer.listen(options.socket);\n  } else {\n    nodeServer.listen(options.port || DEFAULT_PORT, options.host);\n  }\n\n  return nodeServer;\n}\n\nmodule.exports = serveApp;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/multipart.js":"var d = require('describe-property');\nvar parseContent = require('../multipart/parseContent');\n\nvar BOUNDARY_MATCHER = /^multipart\\/.*boundary=(?:\"([^\"]+)\"|([^;]+))/im;\nvar NAME_MATCHER = /\\bname=\"([^\"]+)\"/i;\n\nmodule.exports = function (mach) {\n  mach.Message.PARSERS['multipart/form-data'] = function (message, maxLength) {\n    function partHandler(part) {\n      return message.handlePart(part);\n    }\n\n    // If the content has been buffered, use the buffer.\n    if (message.isBuffered) {\n      return message.bufferContent().then(function (content) {\n        return parseContent(content, message.multipartBoundary, maxLength, partHandler);\n      });\n    }\n\n    return parseContent(message.content, message.multipartBoundary, maxLength, partHandler);\n  };\n\n  Object.defineProperties(mach.Message.prototype, {\n\n    /**\n     * The value that was used as the boundary for multipart content. This\n     * is present only in multipart messages.\n     */\n    multipartBoundary: d.gs(function () {\n      var contentType = this.contentType, match;\n      return (contentType && (match = contentType.match(BOUNDARY_MATCHER))) ? (match[1] || match[2]) : null;\n    }),\n\n    /**\n     * The unique \"name\" or ID of this message, as given in its Content-Disposition\n     * header. This is usually present only on messages that are part of a larger,\n     * multipart message.\n     */\n    name: d.gs(function () {\n      var contentDisposition = this.headers['Content-Disposition'], match;\n      return (contentDisposition && (match = contentDisposition.match(NAME_MATCHER))) ? match[1] : this.headers['Content-ID'];\n    }),\n\n    /**\n     * The filename of this message, as given in its Content-Disposition header.\n     * This is usually present only on messages that are part of a larger, multipart\n     * message and that originate from a file upload.\n     */\n    filename: d.gs(function () {\n      var contentDisposition = this.headers['Content-Disposition'];\n\n      if (contentDisposition) {\n        // Match quoted filenames.\n        var match = contentDisposition.match(/filename=\"([^;]*)\"/i);\n\n        var filename;\n        if (match) {\n          filename = decodeURIComponent(match[1].replace(/\\\\\"/g, '\"'));\n        } else {\n          // Match unquoted filenames.\n          match = contentDisposition.match(/filename=([^;]+)/i);\n\n          if (match)\n            filename = decodeURIComponent(match[1]);\n        }\n\n        if (filename) {\n          // Take the last part of the filename. This handles full Windows\n          // paths given by IE (and possibly other dumb clients).\n          return filename.substr(filename.lastIndexOf('\\\\') + 1);\n        }\n      }\n\n      return null;\n    }),\n\n    /**\n     * A low-level hook responsible for handling Message objects embedded as multipart\n     * objects inside this message. It should return the value to use for the given\n     * message in the parameters hash. By default parts that originate from file uploads\n     * are buffered and all others are converted to strings.\n     *\n     * This should be overridden if you want to specify some kind of custom handling\n     * for multipart data, such as streaming it directly to a network file storage.\n     * For example, the server extension overrides this method to save uploaded files\n     * to a temporary location on disk.\n     */\n    handlePart: d(function (part) {\n      return part.filename ? part.bufferContent() : part.stringifyContent();\n    })\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/multipart/parseContent.js":"var Stream = require('bufferedstream');\nvar MaxLengthExceededError = require('../utils/MaxLengthExceededError');\nvar resolveProperties = require('../utils/resolveProperties');\nvar Promise = require('../utils/Promise');\nvar Parser = require('./Parser');\n\nfunction defaultPartHandler(part) {\n  return part.parseContent();\n}\n\n/**\n * Parses a multipart message and returns a promise for an object of\n * the parts it contains, keyed by the name of that part. The partHandler\n * argument is a function that should be used to resolve the value of\n * a part. It defaults to collecting all the content in a buffer.\n */\nfunction parseContent(content, boundary, maxLength, partHandler) {\n  if (typeof maxLength === 'function') {\n    partHandler = maxLength;\n    maxLength = null;\n  }\n\n  partHandler = partHandler || defaultPartHandler;\n  maxLength = maxLength || Infinity;\n\n  return new Promise(function (resolve, reject) {\n    if (!(content instanceof Stream))\n      content = new Stream(content);\n\n    var parts = {};\n    var contentLength = 0;\n\n    var parser = new Parser(boundary, function (part) {\n      parts[part.name] = partHandler(part);\n    });\n\n    content.on('error', reject);\n\n    content.on('data', function (chunk) {\n      var length = chunk.length;\n      contentLength += length;\n\n      if (maxLength && contentLength > maxLength) {\n        reject(new MaxLengthExceededError(maxLength));\n      } else {\n        var parsedLength = parser.execute(chunk);\n\n        if (parsedLength !== length)\n          reject(new Error('Error parsing multipart body: ' + parsedLength + ' of ' + length + ' bytes parsed'));\n      }\n    });\n\n    content.on('end', function () {\n      try {\n        parser.finish();\n        resolve(resolveProperties(parts));\n      } catch (error) {\n        reject(new Error('Error parsing multipart body: ' + error.message));\n      }\n    });\n\n    content.resume();\n  });\n}\n\nmodule.exports = parseContent;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/resolveProperties.js":"var Promise = require('./Promise');\n\nfunction resolveProperties(object) {\n  var keys = Object.keys(object);\n\n  return Promise.all(\n    keys.map(function (key) {\n      return object[key];\n    })\n  ).then(function (values) {\n    keys.forEach(function (key, index) {\n      object[key] = values[index];\n    });\n\n    return object;\n  });\n}\n\nmodule.exports = resolveProperties;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/multipart/Parser.js":"/* jshint -W058 */\nvar bodec = require('bodec');\nvar Stream = require('bufferedstream');\nvar Message = require('../Message');\n\n// This parser is modified from the one in the node-formidable\n// project, written by Felix Geisendrfer. MIT licensed.\n\nvar s = 0;\nvar S = {\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++\n};\n\nvar f = 1;\nvar F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\n\nvar LF = 10;\nvar CR = 13;\nvar SPACE = 32;\nvar HYPHEN = 45;\nvar COLON = 58;\n\nfunction Parser(boundary, partHandler) {\n  this.boundary = bodec.fromRaw('\\r\\n--' + boundary);\n  this.lookBehind = bodec.create(this.boundary.length + 8);\n  this.boundaryChars = {};\n\n  var i = this.boundary.length;\n  while (i)\n    this.boundaryChars[this.boundary[--i]] = true;\n\n  this.state = S.START;\n  this.index = null;\n  this.flags = 0;\n\n  if (typeof partHandler !== 'function')\n    throw new Error('multipart.Parser needs a part handler');\n\n  this.onPart = partHandler;\n}\n\nParser.prototype.execute = function (chunk) {\n  var chunkLength = chunk.length,\n      prevIndex = this.index,\n      index = this.index,\n      state = this.state,\n      flags = this.flags,\n      lookBehind = this.lookBehind,\n      boundary = this.boundary,\n      boundaryChars = this.boundaryChars,\n      boundaryLength = boundary.length,\n      boundaryEnd = boundaryLength - 1,\n      c,\n      cl;\n\n  for (var i = 0; i < chunkLength; ++i) {\n    c = chunk[i];\n\n    switch (state) {\n    case S.START:\n      index = 0;\n      state = S.START_BOUNDARY;\n      /* falls through */\n    case S.START_BOUNDARY:\n      if (index == boundaryLength - 2) {\n        if (c != CR) {\n          return i;\n        }\n        index++;\n        break;\n      } else if (index == boundaryLength - 1) {\n        if (c != LF) {\n          return i;\n        }\n        index = 0;\n        this._callback('partBegin');\n        state = S.HEADER_FIELD_START;\n        break;\n      }\n\n      if (c != boundary[index + 2]) {\n        return i;\n      }\n      index++;\n      break;\n    case S.HEADER_FIELD_START:\n      state = S.HEADER_FIELD;\n      this._mark('headerName', i);\n      index = 0;\n      /* falls through */\n    case S.HEADER_FIELD:\n      if (c == CR) {\n        this._clear('headerName');\n        state = S.HEADERS_ALMOST_DONE;\n        break;\n      }\n\n      index++;\n      if (c == HYPHEN) {\n        break;\n      }\n\n      if (c == COLON) {\n        if (index == 1) {\n          // empty header field\n          return i;\n        }\n        this._dataCallback('headerName', chunk, true, i);\n        state = S.HEADER_VALUE_START;\n        break;\n      }\n\n      cl = c | 0x20; // lower-case\n      if (cl < 97 || cl > 122) { // not between \"a\" and \"z\"\n        return i;\n      }\n      break;\n    case S.HEADER_VALUE_START:\n      if (c == SPACE) {\n        break;\n      }\n      this._mark('headerValue', i);\n      state = S.HEADER_VALUE;\n      /* falls through */\n    case S.HEADER_VALUE:\n      if (c == CR) {\n        this._dataCallback('headerValue', chunk, true, i);\n        this._callback('headerEnd');\n        state = S.HEADER_VALUE_ALMOST_DONE;\n      }\n      break;\n    case S.HEADER_VALUE_ALMOST_DONE:\n      if (c != LF) {\n        return i;\n      }\n      state = S.HEADER_FIELD_START;\n      break;\n    case S.HEADERS_ALMOST_DONE:\n      if (c != LF) {\n        return i;\n      }\n      this._callback('headersEnd');\n      state = S.PART_DATA_START;\n      break;\n    case S.PART_DATA_START:\n      state = S.PART_DATA;\n      this._mark('partData', i);\n      /* falls through */\n    case S.PART_DATA:\n      prevIndex = index;\n\n      if (index === 0) {\n        // boyer-moore derrived algorithm to safely skip non-boundary data\n        i += boundaryEnd;\n        while (i < chunkLength && !(chunk[i] in boundaryChars)) {\n          i += boundaryLength;\n        }\n        i -= boundaryEnd;\n        c = chunk[i];\n      }\n\n      if (index < boundaryLength) {\n        if (boundary[index] == c) {\n          if (index === 0) {\n            this._dataCallback('partData', chunk, true, i);\n          }\n          index++;\n        } else {\n          index = 0;\n        }\n      } else if (index == boundaryLength) {\n        index++;\n        if (c == CR) {\n          // CR = part boundary\n          flags |= F.PART_BOUNDARY;\n        } else if (c == HYPHEN) {\n          // HYPHEN = end boundary\n          flags |= F.LAST_BOUNDARY;\n        } else {\n          index = 0;\n        }\n      } else if (index - 1 == boundaryLength) {\n        if (flags & F.PART_BOUNDARY) {\n          index = 0;\n          if (c == LF) {\n            // unset the PART_BOUNDARY flag\n            flags &= ~F.PART_BOUNDARY;\n            this._callback('partEnd');\n            this._callback('partBegin');\n            state = S.HEADER_FIELD_START;\n            break;\n          }\n        } else if (flags & F.LAST_BOUNDARY) {\n          if (c == HYPHEN) {\n            this._callback('partEnd');\n            // this._callback('end');\n            state = S.END;\n          } else {\n            index = 0;\n          }\n        } else {\n          index = 0;\n        }\n      }\n\n      if (index > 0) {\n        // when matching a possible boundary, keep a lookBehind\n        // reference in case it turns out to be a false lead\n        lookBehind[index - 1] = c;\n      } else if (prevIndex > 0) {\n        // if our boundary turned out to be rubbish, the captured\n        // lookBehind belongs to partData\n        this._callback('partData', lookBehind, 0, prevIndex);\n        prevIndex = 0;\n        this._mark('partData', i);\n\n        // reconsider the current character even so it interrupted the\n        // sequence it could be the beginning of a new sequence\n        i--;\n      }\n\n      break;\n    case S.END:\n      break;\n    default:\n      return i;\n    }\n  }\n\n  this._dataCallback('headerName', chunk);\n  this._dataCallback('headerValue', chunk);\n  this._dataCallback('partData', chunk);\n\n  this.index = index;\n  this.state = state;\n  this.flags = flags;\n\n  return chunkLength;\n};\n\nParser.prototype.finish = function () {\n  if (this.state !== S.END)\n    throw new Error('Stream ended unexpectedly (state: ' + this.state + ')');\n};\n\nParser.prototype._mark = function (name, i) {\n  this[name + 'Mark'] = i;\n};\n\nParser.prototype._clear = function (name) {\n  delete this[name + 'Mark'];\n};\n\nParser.prototype._callback = function (name, chunk, start, end) {\n  if (start !== undefined && start === end)\n    return;\n\n  var prop = 'on' + name.substr(0, 1).toUpperCase() + name.substr(1);\n\n  if (prop in this)\n    this[prop](chunk, start, end);\n};\n\nParser.prototype._dataCallback = function (name, chunk, clear, i) {\n  var prop = name + 'Mark';\n\n  if (prop in this) {\n    if (!clear) {\n      this._callback(name, chunk, this[prop], chunk.length);\n      this[prop] = 0;\n    } else {\n      this._callback(name, chunk, this[prop], i);\n      delete this[prop];\n    }\n  }\n};\n\nParser.prototype.onPartBegin = function () {\n  this._stream = new Stream;\n  this._part = new Message(this._stream);\n  this._headerName = '';\n  this._headerValue = '';\n};\n\nParser.prototype.onHeaderName = function (chunk, start, end) {\n  this._headerName += bodec.toUnicode(chunk, start, end);\n};\n\nParser.prototype.onHeaderValue = function (chunk, start, end) {\n  this._headerValue += bodec.toUnicode(chunk, start, end);\n};\n\nParser.prototype.onHeaderEnd = function () {\n  this._part.setHeader(this._headerName, this._headerValue);\n  this._headerName = '';\n  this._headerValue = '';\n};\n\nParser.prototype.onHeadersEnd = function () {\n  this.onPart(this._part);\n};\n\nParser.prototype.onPartData = function (chunk, start, end) {\n  this._stream.write(bodec.slice(chunk, start, end));\n};\n\nParser.prototype.onPartEnd = function () {\n  this._stream.end();\n};\n\nmodule.exports = Parser;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/catch.js":"/**\n * A middleware that \"catches\" non-Errors that are thrown from the downstream\n * app and returns them instead. This can be useful for breaking out of a\n * nested promise chain, for example.\n *\n * Example:\n *\n *   mach.catch(function (conn) {\n *     throw 200;\n *   });\n */\nfunction catchError(app) {\n  return function (conn) {\n    return conn.call(app).then(undefined, function (reason) {\n      if (reason instanceof Error)\n        throw reason;\n      \n      return reason;\n    });\n  };\n}\n\nmodule.exports = catchError;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/charset.js":"/**\n * A middleware that sets a default character set in the Content-Type\n * header of the response if none is already specified.\n */\nfunction charset(app, defaultCharset) {\n  defaultCharset = defaultCharset || 'utf-8';\n\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var response = conn.response;\n\n      if (response.contentType && response.charset == null)\n        response.charset = defaultCharset;\n    });\n  };\n}\n\nmodule.exports = charset;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/contentType.js":"/**\n * A middleware that sets a default Content-Type header in case one hasn't\n * already been set in a downstream app.\n */\nfunction contentType(app, defaultType) {\n  defaultType = defaultType || 'text/html';\n\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var headers = conn.response.headers;\n\n      if (!headers['Content-Type'])\n        headers['Content-Type'] = defaultType;\n    });\n  };\n}\n\nmodule.exports = contentType;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/favicon.js":"/**\n * A middleware that returns the given response to requests for \"/favicon.ico\".\n * Defaults to returning an empty 404.\n */\nfunction favicon(app, response) {\n  response = response || 404;\n\n  return function (conn) {\n    return conn.pathname === '/favicon.ico' ? response : conn.call(app);\n  };\n}\n\nmodule.exports = favicon;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/file.js":"var fs = require('fs');\nvar mach = require('../index');\nvar Promise = require('../utils/Promise');\nvar getFileStats = require('../utils/getFileStats');\nvar generateETag = require('../utils/generateETag');\nvar generateIndex = require('../utils/generateIndex');\nvar joinPaths = require('../utils/joinPaths');\n\nmach.extend(\n  require('../extensions/server')\n);\n\n/**\n * A middleware for serving files efficiently from the file system according\n * to the path specified in the `pathname` variable.\n *\n * Options may be any of the following:\n *\n * - root               The path to the root directory to serve files from\n * - index              An array of file names to try and serve when the\n *                      request targets a directory (e.g. [\"index.html\", \"index.htm\"]).\n *                      May simply be truthy to use [\"index.html\"]\n * - autoIndex          Set this true to automatically generate an index page\n *                      listing a directory's contents when the request targets\n *                      a directory with no index file\n * - useLastModified    Set this true to include the Last-Modified header\n *                      based on the mtime of the file. Defaults to true\n * - useETag            Set this true to include the ETag header based on\n *                      the MD5 checksum of the file. Defaults to false\n *\n * Alternatively, options may be a file path to the root directory.\n *\n * If a matching file cannot be found, the request is forwarded to the\n * downstream app. Otherwise, the file is streamed through to the response.\n *\n * Examples:\n *\n *   // Use the root directory name directly.\n *   app.use(mach.file, '/public');\n *\n *   // Serve static files out of /public, and automatically\n *   // serve an index.htm from any directory that has one.\n *   app.use(mach.file, {\n *     root: '/public',\n *     index: 'index.htm',\n *     useETag: true\n *   });\n *\n *   // Serve static files out of /public, and automatically\n *   // serve an index.html from any directory that has one.\n *   // Also, automatically generate a directory listing for\n *   // any directory without an index.html file.\n *   app.use(mach.file, {\n *     root: '/public',\n *     index: true,\n *     autoIndex: true\n *   });\n *\n * This function may also be used outside of the context of a middleware\n * stack to create a standalone app.\n *\n *   var app = mach.file('/public');\n *   mach.serve(app);\n */\nfunction file(app, options) {\n  // Allow mach.file(path|options)\n  if (typeof app === 'string' || typeof app === 'object') {\n    options = app;\n    app = null;\n  }\n\n  options = options || {};\n\n  // Allow mach.file(path) and app.use(mach.file, path)\n  if (typeof options === 'string')\n    options = { root: options };\n\n  var root = options.root;\n  if (typeof root !== 'string' || !fs.existsSync(root) || !fs.statSync(root).isDirectory())\n    throw new Error('Invalid root directory: ' + root);\n\n  var index = options.index || [];\n  if (index) {\n    if (typeof index === 'string') {\n      index = [ index ];\n    } else if (!Array.isArray(index)) {\n      index = [ 'index.html' ];\n    }\n  }\n\n  var useLastModified = ('useLastModified' in options) ? !!options.useLastModified : true;\n  var useETag = !!options.useETag;\n\n  function sendFile(conn, path, stats) {\n    conn.file({\n      path: path,\n      size: stats.size\n    });\n\n    if (useLastModified)\n      conn.response.headers['Last-Modified'] = stats.mtime.toUTCString();\n\n    if (useETag) {\n      return generateETag(path).then(function (etag) {\n        conn.response.headers.ETag = etag;\n      });\n    }\n  }\n\n  return function (conn) {\n    if (conn.method !== 'GET' && conn.method !== 'HEAD')\n      return conn.call(app);\n\n    var pathname = conn.pathname;\n\n    // Reject paths that contain \"..\".\n    if (pathname.indexOf('..') !== -1)\n      return conn.text(403, 'Forbidden');\n\n    var path = joinPaths(root, pathname);\n\n    return getFileStats(path).then(function (stats) {\n      if (stats && stats.isFile())\n        return sendFile(conn, path, stats);\n\n      if (!stats || !stats.isDirectory())\n        return conn.call(app);\n\n      // Try to serve one of the index files.\n      var indexPaths = index.map(function (indexPath) {\n        return joinPaths(path, indexPath);\n      });\n\n      return Promise.all(indexPaths.map(getFileStats)).then(function (stats) {\n        for (var i = 0, len = stats.length; i < len; ++i)\n          if (stats[i])\n            return sendFile(conn, indexPaths[i], stats[i]);\n\n        if (!options.autoIndex)\n          return conn.call(app);\n\n        // Redirect /images => /images/\n        if (!(/\\/$/).test(pathname))\n          return conn.redirect(pathname + '/');\n\n        // Automatically generate and serve an index file.\n        return generateIndex(root, pathname, conn.basename).then(function (html) {\n          conn.html(html);\n        });\n      });\n    });\n  };\n}\n\nmodule.exports = file;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/getFileStats.js":"var fs = require('fs');\nvar Promise = require('./Promise');\n\n/**\n * Returns stats for the given file or null if it doesn't exist.\n */\nfunction getFileStats(path) {\n  return new Promise(function (resolve, reject) {\n    fs.stat(path, function (error, stats) {\n      if (error && error.code !== 'ENOENT') {\n        reject(error);\n      } else {\n        resolve(stats || null);\n      }\n    });\n  });\n}\n\nmodule.exports = getFileStats;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/generateETag.js":"var fs = require('fs');\nvar crypto = require('crypto');\nvar Promise = require('./Promise');\n\nfunction generateETag(path) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(path, function (error, data) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve('\"' + crypto.createHash('md5').update(data).digest('hex') + '\"');\n      }\n    });\n  });\n}\n\nmodule.exports = generateETag;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/generateIndex.js":"var fs = require('fs');\nvar Promise = require('./Promise');\nvar getFileStats = require('./getFileStats');\nvar getMimeType = require('./getMimeType');\nvar formatByteSize = require('./formatByteSize');\nvar formatString = require('util').format;\nvar joinPaths = require('./joinPaths');\n\nvar MACH_VERSION = require('../version');\n\nvar PAGE_TEMPLATE = [\n  '<html>',\n  '<head>',\n  '<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />',\n  '<title>%s</title>',\n  '<style type=\"text/css\">',\n  '  body { font: 14px Helvetica, Arial, sans-serif; padding: 0 10px; }',\n  '  address { text-align: right; font-style: italic; }',\n  '  table { width: 100%; }',\n  '  tr.even { background: #f3f3f3; }',\n  '  .name { text-align: left; }',\n  '  .size, .type, .mtime { text-align: right; }',\n  '</style>',\n  '</head>',\n  '<body>',\n  '<h1>%s</h1>',\n  '<hr>',\n  '<table cellspacing=\"0\" cellpadding=\"3\">',\n  '<tr>',\n  '  <th class=\"name\">Name</th>',\n  '  <th class=\"size\">Size</th>',\n  '  <th class=\"type\">Type</th>',\n  '  <th class=\"mtime\">Last Modified</th>',\n  '</tr>',\n  '%s',\n  '</table>',\n  '<hr>',\n  '<address>%s/%s</address>',\n  '</body>',\n  '</html>'\n].join('\\n');\n\nvar ROW_TEMPLATE = [\n  '<tr class=\"%s\">',\n  '  <td class=\"name\"><a href=\"%s\">%s</a></td>',\n  '  <td class=\"size\">%s</td>',\n  '  <td class=\"type\">%s</td>',\n  '  <td class=\"mtime\">%s</td>',\n  '</tr>'\n].join('\\n');\n\nfunction generateIndex(root, pathname, basename) {\n  return new Promise(function (resolve, reject) {\n    var path = joinPaths(root, pathname);\n\n    fs.readdir(path, function (error, files) {\n      if (error)\n        return reject(error);\n\n      var promises = files.map(function (file) {\n        return getFileStats(joinPaths(path, file));\n      });\n\n      Promise.all(promises).then(function (statsArray) {\n        var rows = formatString(ROW_TEMPLATE, '', '../', 'Parent Directory', '', '', '');\n        var className = 'even';\n\n        statsArray.forEach(function (stats, index) {\n          if (stats == null)\n            return; // Ignore broken symlinks!\n\n          var file = files[index];\n          var url = basename + pathname + file;\n          var mtime = stats.mtime;\n\n          var size, type;\n          if (stats.isDirectory()) {\n            size = '-';\n            type = 'directory';\n            url += '/';\n            file += '/';\n          } else {\n            size = formatByteSize(stats.size);\n            type = getMimeType(file);\n          }\n\n          rows += '\\n' + formatString(ROW_TEMPLATE, className, url, file, size, type, mtime);\n\n          className = (className === 'even') ? 'odd' : 'even';\n        });\n\n        var title = 'Index of ' + basename + pathname;\n        var content = formatString(PAGE_TEMPLATE, title, title, rows, 'mach', MACH_VERSION);\n\n        resolve(content);\n      }, reject);\n    });\n  });\n}\n\nmodule.exports = generateIndex;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/formatByteSize.js":"var SUFFIXES = [ 'B', 'K', 'M', 'G', 'T' ];\n\nfunction formatByteSize(size) {\n  var tier = size > 0 ? Math.floor(Math.log(size) / Math.log(1024)) : 0;\n  var n = size / Math.pow(1024, tier);\n\n  if (tier > 0)\n    n = Math.floor(n * 10) / 10; // Preserve only 1 digit after decimal.\n\n  return String(n) + SUFFIXES[tier];\n}\n\nmodule.exports = formatByteSize;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/joinPaths.js":"module.exports = require('path').join;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/gzip.js":"var zlib = require('zlib');\nvar mach = require('../index');\n\nmach.extend(\n  require('../extensions/acceptEncoding')\n);\n\nvar GZIP_MATCHER = /text|javascript|json/i;\n\nfunction shouldGzipContentType(contentType) {\n  if (!contentType || contentType === 'text/event-stream')\n    return false;\n\n  return GZIP_MATCHER.test(contentType);\n}\n\n/**\n * A middleware that gzip's the response content (see http://www.gzip.org/).\n * Options may be any of node's zlib options (see http://nodejs.org/api/zlib.html).\n */\nfunction gzip(app, options) {\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var response = conn.response;\n      var headers = response.headers;\n\n      if (shouldGzipContentType(headers['Content-Type']) && conn.acceptsEncoding('gzip')) {\n        response.content = response.content.pipe(zlib.createGzip(options));\n\n        delete headers['Content-Length'];\n        headers['Content-Encoding'] = 'gzip';\n        headers['Vary'] = 'Accept-Encoding';\n      }\n    });\n  };\n}\n\nmodule.exports = gzip;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/logger.js":"/* jshint -W058 */\nvar strftime = require('strftime').strftime;\n\nfunction defaultMessageHandler(message) {\n  if (typeof console !== 'undefined' && console.log)\n    console.log(message);\n}\n\n/**\n * A middleware that writes log entry data about the response to a given stream.\n * Log entries are formatted similarly to Apache httpd's Common Log Format\n * (see http://httpd.apache.org/docs/1.3/logs.html#common).\n */\nfunction logger(app, messageHandler) {\n  messageHandler = messageHandler || defaultMessageHandler;\n\n  return function (conn) {\n    var startTime = Date.now();\n\n    return conn.call(app).then(function () {\n      var elapsedTime = Date.now() - startTime;\n      var contentLength = conn.response.headers['Content-Length'];\n\n      if (contentLength == null)\n        contentLength = '-';\n\n      var protocol = conn.protocol || 'http:';\n      protocol = protocol.substr(0, protocol.length - 1).toUpperCase();\n\n      // 127.0.0.1 - frank [10/Oct/2000 13:55:36] \"GET /apache_pb.gif HTTP/1.0\" 200 2326 0.003\n      messageHandler([\n        conn.remoteHost || '-',\n        '-', // RFC 1413 identity of the client\n        conn.remoteUser || '-',\n        '[' + strftime('%d/%b/%Y %H:%M:%S', new Date) + ']',\n        '\"' + conn.method + ' ' + conn.basename + conn.path + ' ' + protocol + '/' + conn.version + '\"',\n        conn.status,\n        contentLength,\n        elapsedTime / 1000\n      ].join(' '));\n    });\n  };\n}\n\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/mapper.js":"var d = require('describe-property');\nvar escapeRegExp = require('../utils/escapeRegExp');\n\nfunction byMostSpecific(a, b) {\n  return (b.path.length - a.path.length) || ((b.host || '').length - (a.host || '').length);\n}\n\n/**\n * A middleware that provides host and/or location-based routing. Modifies\n * the `basename` connection variable for all downstream apps such that only\n * the portion relevant for dispatch remains in `pathname`.\n *\n *   app.use(mach.mapper, {\n *\n *     'http://example.com/images': function (conn) {\n *       // The hostname used in the request was example.com, and\n *       // the URL path started with \"/images\". If the request was\n *       // GET /images/avatar.jpg, then conn.pathname is /avatar.jpg\n *     },\n *\n *     '/images': function (conn) {\n *       // The URL path started with \"/images\"\n *     }\n *\n *   });\n *\n * This function may also be used outside of the context of a middleware\n * stack to create a standalone app. You can either provide mappings one\n * at a time:\n *\n *   var app = mach.mapper();\n *\n *   app.map('/images', function (conn) {\n *     // ...\n *   });\n *\n * Or all at once:\n *\n *   var app = mach.mapper({\n *\n *     '/images': function (conn) {\n *       // ...\n *     }\n *\n *   });\n *\n * Note: Dispatch is done in such a way that the longest paths are tried first\n * since they are the most specific.\n */\nfunction createMapper(app, map) {\n  // Allow mach.mapper(map)\n  if (typeof app === 'object') {\n    map = app;\n    app = null;\n  }\n  \n  var mappings = [];\n\n  function mapper(conn) {\n    var hostname = conn.hostname;\n    var pathname = conn.pathname;\n\n    var mapping, match, remainingPath;\n    for (var i = 0, len = mappings.length; i < len; ++i) {\n      mapping = mappings[i];\n\n      // Try to match the hostname.\n      if (mapping.hostname && mapping.hostname !== hostname)\n        continue;\n\n      // Try to match the path.\n      if (!(match = pathname.match(mapping.pattern))) \n        continue;\n\n      // Skip if the remaining path doesn't start with a \"/\".\n      remainingPath = match[1];\n      if (remainingPath.length > 0 && remainingPath[0] !== '/')\n        continue;\n\n      conn.basename += mapping.path;\n\n      return conn.call(mapping.app);\n    }\n\n    return conn.call(app);\n  }\n\n  Object.defineProperties(mapper, {\n\n    /**\n     * Adds a new mapping that runs the given app when the location used in the\n     * request matches the given location.\n     */\n    map: d(function (location, app) {\n      var hostname, path;\n\n      // If the location is a fully qualified URL use the host as well.\n      var match = location.match(/^https?:\\/\\/(.*?)(\\/.*)/);\n      if (match) {\n        hostname = match[1].replace(/:\\d+$/, ''); // Strip the port.\n        path = match[2];\n      } else {\n        path = location;\n      }\n\n      if (path.charAt(0) !== '/')\n        throw new Error('Mapping path must start with \"/\", was \"' + path + '\"');\n\n      path = path.replace(/\\/$/, '');\n\n      var pattern = new RegExp('^' + escapeRegExp(path).replace(/\\/+/g, '/+') + '(.*)');\n\n      mappings.push({\n        hostname: hostname,\n        path: path,\n        pattern: pattern,\n        app: app\n      });\n\n      mappings.sort(byMostSpecific);\n    }),\n\n    /**\n     * Sets the given app as the default for this mapper.\n     */\n    run: d(function (downstreamApp) {\n      app = downstreamApp;\n    })\n\n  });\n\n  // Allow app.use(mach.mapper, map)\n  if (typeof map === 'object')\n    for (var location in map)\n      if (map.hasOwnProperty(location))\n        mapper.map(location, map[location]);\n\n  return mapper;\n}\n\nmodule.exports = createMapper;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/escapeRegExp.js":"/**\n * Escapes all special RegExp characters in the given string.\n */\nfunction escapeRegExp(string) {\n  return String(string).replace(/([.?*+^$[\\]\\\\(){}-])/g, '\\\\$1');\n}\n\nmodule.exports = escapeRegExp;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/methodOverride.js":"var normalizeHeaderName = require('../utils/normalizeHeaderName');\n\n/**\n * A middleware that overrides the method of the request to a value that was\n * given either in a request parameter or a request header. Can be useful when\n * you need to use HTTP methods other than GET and POST with clients that don't\n * support them, like web browsers.\n *\n * For example, you could use the following HTML form:\n *\n *   <form method=\"POST\" action=\"/\">\n *     <input type=\"hidden\" name=\"_method\" value=\"PUT\">\n *   </form>\n *\n * with an app that uses methodOverride:\n *\n *   var app = mach.stack();\n *   app.use(mach.params);\n *   app.use(mach.methodOverride);\n *   app.run(function (request) {\n *     return request.method; // PUT\n *   });\n *\n * Note: When using mach.methodOverride with POST parameters you need to put\n * mach.params in front of it so that the request parameters will be available.\n *\n * Options may be any of the following:\n *\n * - paramName        The name of the request param that contains the\n *                    request method. Defaults to \"_method\"\n * - headerName       The name of the HTTP header that will contain the\n *                    request method. This allows you to put the request\n *                    method in an HTTP header instead of a request param.\n *                    Defaults to \"X-Http-Method-Override\"\n */\nfunction methodOverride(app, options) {\n  options = options || {};\n\n  if (typeof options === 'string')\n    options = { paramName: options };\n\n  var paramName = options.paramName || '_method';\n  var headerName = normalizeHeaderName(options.headerName || 'X-Http-Method-Override');\n\n  return function (conn) {\n    var method;\n    if (conn.request.headers[headerName]) {\n      method = conn.request.headers[headerName];\n    } else if (!conn.params) {\n      conn.onError(new Error('No params! Use mach.params in front of mach.methodOverride'));\n    } else if (conn.params[paramName]) {\n      method = conn.params[paramName];\n\n      // If multiple _method parameters were used, use the last one.\n      if (Array.isArray(method))\n        method = method[method.length - 1];\n    }\n\n    if (method)\n      conn.method = method.toUpperCase();\n\n    return conn.call(app);\n  };\n}\n\nmodule.exports = methodOverride;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/modified.js":"var stripQuotes = require('../utils/stripQuotes');\n\n/**\n * A middleware that automatically performs content-based HTTP caching in\n * response to requests that use the If-None-Match and/or If-Modified-Since\n * headers. In order to work effectively, downstream apps must use the ETag\n * and/or Last-Modified headers.\n *\n * Example:\n *\n *   app.use(mach.modified);\n *\n *   // Send Last-Modified and ETag headers with static files.\n *   app.use(mach.file, {\n *     useLastModified: true, // this is the default\n *     useETag: true\n *   });\n */\nfunction modified(app) {\n  return function (conn) {\n    return conn.call(app).then(function () {\n      var request = conn.request, response = conn.response;\n\n      var ifNoneMatch = request.headers['If-None-Match'];\n      var etag = response.headers['ETag'];\n\n      if (ifNoneMatch && etag && etag === stripQuotes(ifNoneMatch)) {\n        conn.status = 304;\n        response.content = '';\n        return;\n      }\n\n      var ifModifiedSince = request.headers['If-Modified-Since'];\n      var lastModified = response.headers['Last-Modified'];\n\n      if (ifModifiedSince && lastModified) {\n        if (typeof lastModified === 'string')\n          lastModified = Date.parse(lastModified);\n\n        if (lastModified <= Date.parse(ifModifiedSince)) {\n          conn.status = 304;\n          response.content = '';\n        }\n      }\n    });\n  };\n}\n\nmodule.exports = modified;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/stripQuotes.js":"function stripQuotes(string) {\n  if (string.substring(0, 1) === '\"')\n    return string.replace(/^\"|\"$/g, '');\n\n  return string;\n}\n\nmodule.exports = stripQuotes;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/params.js":"var objectAssign = require('object-assign');\nvar mach = require('../index');\nvar MaxLengthExceededError = require('../utils/MaxLengthExceededError');\n\nmach.extend(\n  require('../extensions/server')\n);\n\n/**\n * Automatically parses all request parameters and stores them in conn.params.\n * This is the union of all GET (query string) and POST (content) parameters,\n * such that all POST parameters with the same name take precedence.\n *\n * Valid options are:\n *\n * - maxLength          The maximum length (in bytes) of the request content\n *\n * If the maximum allowed length is exceeded, this middleware returns a\n * 413 Request Entity Too Large response.\n *\n * Note: This middleware parses all request parameters for all downstream apps. If\n * you'd prefer to only do this work on some requests and not all, you can use\n * conn.getParams inside your app instead.\n */\nfunction parseParams(app, options) {\n  options = options || {};\n\n  if (typeof options === 'number')\n    options = { maxLength: options };\n\n  var maxLength = options.maxLength;\n\n  return function (conn) {\n    return conn.getParams(maxLength).then(function (params) {\n      if (conn.params) {\n        // Route params take precedence over content params.\n        conn.params = objectAssign(params, conn.params);\n      } else {\n        conn.params = params;\n      }\n\n      return conn.call(app);\n    }, function (error) {\n      if (error instanceof MaxLengthExceededError)\n        return conn.text(413, 'Request Entity Too Large');\n\n      throw error;\n    });\n  };\n}\n\nmodule.exports = parseParams;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/proxy.js":"var Location = require('../Location');\nvar createProxy = require('../utils/createProxy');\nvar isRegExp = require('../utils/isRegExp');\n\nfunction returnTrue() {\n  return true;\n}\n\n/**\n * A middleware that forwards requests that pass the given test function\n * to the given target. If the target is not an app, it should be a string\n * or options hash that is used to create a proxy.\n *\n * Example:\n *\n *   var mach = require('mach');\n *   var app = mach.stack();\n *\n *   // Forward all requests to example.com.\n *   app.use(mach.proxy, 'http://www.example.com');\n *\n *   // Forward all requests that match \"/images/*.jpg\" to S3.\n *   app.use(mach.proxy, 'http://s3.amazon.com/my-bucket', /\\/images/*.jpg/);\n *   \n *   mach.serve(app);\n */\nfunction proxy(app, target, test) {\n  test = test || returnTrue;\n\n  if (isRegExp(test)) {\n    var pattern = test;\n    test = function (conn) {\n      return pattern.test(conn.href);\n    };\n  } else if (typeof test !== 'function') {\n    throw new Error('mach.proxy needs a test function');\n  }\n\n  var targetApp;\n  if (typeof target === 'function') {\n    targetApp = target;\n  } else if (typeof target === 'string' || target instanceof Location) {\n    targetApp = createProxy(target);\n  } else {\n    throw new Error('mach.proxy needs a target app');\n  }\n\n  return function (conn) {\n    return conn.call(test(conn) ? targetApp : app);\n  };\n}\n\nmodule.exports = proxy;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/createProxy.js":"var Location = require('../Location');\nvar sendRequest = require('./sendRequest');\n\n/**\n * A proxy is a function that is used to forward a request to\n * a different location and return the response.\n *\n * This function is part of the low-level API and can generally be\n * used more conveniently through the mach.proxy middleware.\n */\nfunction createProxy(location) {\n  if (!(location instanceof Location))\n    location = new Location(location);\n\n  return function (conn) {\n    // Only concat the path from the connection so the protocol,\n    // auth, and host from the original location are preserved.\n    conn.proxyLocation = location.concat(conn.path);\n\n    return sendRequest(conn, conn.proxyLocation);\n  };\n}\n\nmodule.exports = createProxy;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/isRegExp.js":"function isRegExp(object) {\n  return object != null && Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nmodule.exports = isRegExp;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/rewrite.js":"var escapeRegExp = require('../utils/escapeRegExp');\nvar isRegExp = require('../utils/isRegExp');\n\n/**\n * A middleware that provides URL rewriting behavior similar to Apache's\n * mod_rewrite. The pathname of requests that match the given pattern is\n * overwritten with the replacement using a simple String#replace.\n */\nfunction rewrite(app, pattern, replacement) {\n  if (typeof pattern === 'string')\n    pattern = new RegExp('^' + escapeRegExp(pattern) + '$');\n\n  if (!isRegExp(pattern))\n    throw new Error('Rewrite pattern must be a RegExp or String');\n\n  replacement = replacement || '';\n\n  return function (conn) {\n    var pathname = conn.pathname;\n\n    // Modify the pathname if the pattern matches.\n    if (pattern.test(pathname))\n      conn.location.properties.pathname = conn.basename + pathname.replace(pattern, replacement);\n\n    return conn.call(app);\n  };\n}\n\nmodule.exports = rewrite;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/router.js":"/* jshint -W084 */\nvar d = require('describe-property');\nvar objectAssign = require('object-assign');\nvar compileRoute = require('../utils/compileRoute');\nvar isRegExp = require('../utils/isRegExp');\nvar makeParams = require('../utils/makeParams');\nvar RoutingProperties = require('../utils/RoutingProperties');\n\nvar LEADING_HTTP_METHOD_MATCHER = /^(DELETE|GET|HEAD|OPTIONS|POST|PUT|TRACE)\\s+(.+)$/;\n\n/**\n * A middleware that provides pattern-based routing for URLs, with optional\n * support for restricting matches to a specific request method. Named segments\n * of the URL are added to conn.params and take precedence over all others.\n *\n *   app.use(mach.router, {\n *\n *     'GET /login': function (conn) {\n *       // conn.method == 'GET'\n *       // conn.pathname == '/login'\n *     },\n *\n *     'POST /login': function (conn) {\n *       // conn.method == 'POST'\n *       // conn.pathname == '/login'\n *     },\n *\n *     'DELETE /users/:id': function (conn) {\n *       // conn.method == 'DELETE'\n *       // conn.pathname == '/users/5'\n *       // conn.params == { id: 5 }\n *     }\n *\n *   });\n *\n * This function may also be used outside the context of a middleware stack\n * to create a standalone app. Routes may be given one at a time:\n *\n *   var app = mach.router();\n *\n *   app.get('/login', function (conn) {\n *     // ...\n *   });\n *\n *   app.delete('/users/:id', function (conn) {\n *     // ...\n *   });\n *\n * Or all at once:\n *\n *   var app = mach.router({\n *\n *     'GET /login': function (conn) {\n *       // ...\n *     },\n *\n *     'DELETE /users/:id': function (conn) {\n *       // ...\n *     }\n *\n *   });\n *\n * Note: Routes are always tried in the order they were defined.\n */\nfunction createRouter(app, map) {\n  // Allow mach.router(map)\n  if (typeof app === 'object') {\n    map = app;\n    app = null;\n  }\n\n  var routes = {};\n\n  function router(conn) {\n    var method = conn.method;\n    var routesToTry = (routes[method] || []).concat(routes.ANY || []);\n\n    var route, match;\n    for (var i = 0, len = routesToTry.length; i < len; ++i) {\n      route = routesToTry[i];\n\n      // Try to match the route.\n      if (match = route.pattern.exec(conn.pathname)) {\n        var params = makeParams(route.keys, Array.prototype.slice.call(match, 1));\n\n        if (conn.params) {\n          // Route params take precedence above all others.\n          objectAssign(conn.params, params);\n        } else {\n          conn.params = params;\n        }\n\n        return conn.call(route.app);\n      }\n    }\n\n    return conn.call(app);\n  }\n\n  Object.defineProperties(router, {\n\n    /**\n     * Adds a new route that runs the given app when the pattern matches the\n     * path used in the request. If the pattern is a string, it is automatically\n     * compiled. The following signatures are supported:\n     *\n     *   route('/users/:id', app)\n     *   route('/users/:id', 'PUT', app)\n     *   route('/users/:id', [ 'GET', 'PUT' ], app)\n     *   route('GET /users/:id', app)\n     */\n    route: d(function (pattern, methods, app) {\n      if (typeof methods === 'function') {\n        app = methods;\n        methods = null;\n      }\n\n      if (typeof app !== 'function')\n        throw new Error('Route needs an app');\n\n      if (typeof methods === 'string') {\n        methods = [ methods ];\n      } else if (!Array.isArray(methods)) {\n        methods = [];\n      }\n\n      var keys = [];\n\n      if (typeof pattern === 'string') {\n        var match;\n\n        if (match = pattern.match(LEADING_HTTP_METHOD_MATCHER)) {\n          methods.push(match[1]);\n          pattern = match[2];\n        }\n\n        pattern = compileRoute(pattern, keys);\n      }\n\n      if (!isRegExp(pattern))\n        throw new Error('Route pattern must be a RegExp');\n\n      var route = { pattern: pattern, keys: keys, app: app };\n\n      if (methods.length === 0)\n        methods.push('ANY');\n\n      methods.forEach(function (method) {\n        var upperMethod = method.toUpperCase();\n\n        if (routes[upperMethod]) {\n          routes[upperMethod].push(route);\n        } else {\n          routes[upperMethod] = [ route ];\n        }\n      });\n    }),\n\n    /**\n     * Sets the given app as the default for this router.\n     */\n    run: d(function (downstreamApp) {\n      app = downstreamApp;\n    })\n\n  });\n\n  // Allow app.use(mach.router, map)\n  if (typeof map === 'object')\n    for (var route in map)\n      if (map.hasOwnProperty(route))\n        router.route(route, map[route]);\n\n  Object.defineProperties(router, RoutingProperties);\n\n  return router;\n}\n\nmodule.exports = createRouter;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/compileRoute.js":"var paramMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|[*.()\\[\\]\\\\+|{}^$]/g;\n\n/**\n * Compiles the given route string into a RegExp that can be used to\n * match a URL. The route may contain named parameters in the form of\n * a colon followed by a valid JavaScript identifier (e.g. \":name\",\n * \":_name\", and \":$name\" are all valid parameters). The route may\n * also contain a * to match any character non-greedily, or a ? to\n * match the previous thing 0 or 1 time.\n *\n * The keys array is populated with names of all parameters in the\n * order they appear in the route string.\n */\nfunction compileRoute(route, keys) {\n  var source = route.replace(paramMatcher, function (match, key) {\n    if (key) {\n      keys.push(key);\n      return '([^./?#]+)';\n    } else if (match === '*') {\n      keys.push('splat');\n      return '(.*?)';\n    } else {\n      return '\\\\' + match;\n    }\n  });\n\n  return new RegExp('^' + source + '$', 'i');\n}\n\nmodule.exports = compileRoute;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/makeParams.js":"function makeParams(keys, values) {\n  return keys.reduce(function (params, key, index) {\n    var value = values[index];\n\n    if (key === 'splat') {\n      if (Array.isArray(params.splat)) {\n        params.splat.push(value);\n      } else if ('splat' in params) {\n        // Multiple \"splat\" keys make an array.\n        params.splat = [ params.splat, value ];\n      } else {\n        params.splat = value;\n      }\n    } else {\n      params[key] = value;\n    }\n\n    return params;\n  }, {});\n}\n\nmodule.exports = makeParams;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/RoutingProperties.js":"var d = require('describe-property');\n\nvar RoutingMethods = {\n  delete: 'DELETE',\n  get: [ 'GET', 'HEAD' ],\n  head: 'HEAD',\n  options: 'OPTIONS',\n  post: 'POST',\n  put: 'PUT',\n  trace: 'TRACE'\n};\n\nvar RoutingProperties = Object.keys(RoutingMethods).reduce(function (memo, method) {\n  memo[method] = d(function (pattern, app) {\n    return this.route(pattern, RoutingMethods[method], app);\n  });\n\n  return memo;\n}, {});\n\nmodule.exports = RoutingProperties;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/session.js":"var mach = require('../index');\nvar Promise = require('../utils/Promise');\nvar decodeBase64 = require('../utils/decodeBase64');\nvar encodeBase64 = require('../utils/encodeBase64');\nvar makeHash = require('../utils/makeHash');\nvar CookieStore = require('./session/CookieStore');\n\nmach.extend(\n  require('../extensions/server')\n);\n\n/**\n * The maximum size of an HTTP cookie.\n */\nvar MAX_COOKIE_SIZE = 4096;\n\n/**\n * Stores the given session and returns a promise for a value that should be stored\n * in the session cookie to retrieve the session data again on the next request.\n */\nfunction encodeSession(session, store, secret) {\n  return store.save(session).then(function (data) {\n    var cookie = encodeBase64(data + '--' + makeHashWithSecret(data, secret));\n\n    if (cookie.length > MAX_COOKIE_SIZE)\n      throw new Error('Cookie data size exceeds 4kb; content dropped');\n\n    return cookie;\n  });\n}\n\n/**\n * Decodes the given cookie value and returns a promise for the corresponding session\n * data from the store. Also verifies the hash value to ensure the cookie has not been\n * tampered with. If it has, returns null.\n */\nfunction decodeCookie(cookie, store, secret) {\n  var value = decodeBase64(cookie);\n  var index = value.lastIndexOf('--');\n  var data = value.substring(0, index);\n  var hash = value.substring(index + 2);\n\n  // Verify the cookie has not been tampered with.\n  if (hash === makeHashWithSecret(data, secret))\n    return store.load(data);\n\n  return null;\n}\n\nfunction makeHashWithSecret(data, secret) {\n  return makeHash(secret ? data + secret : data);\n}\n\n/**\n * A middleware that provides support for HTTP sessions using cookies.\n *\n * Options may be any of the following:\n *\n * - secret         A cryptographically secure secret key that will be used to verify\n *                  the integrity of session data that is received from the client\n * - name           The name of the cookie. Defaults to \"_session\"\n * - path           The path of the cookie. Defaults to \"/\"\n * - domain         The cookie's domain. Defaults to null\n * - secure         True to only send this cookie over HTTPS. Defaults to false\n * - expireAfter    The number of seconds after which sessions expire. Defaults\n *                  to 0 (no expiration)\n * - httpOnly       True to restrict access to this cookie to HTTP(S) APIs.\n *                  Defaults to true\n * - store          An instance of MemoryStore, CookieStore, or RedisStore that\n *                  is used to store session data. Defaults to a new CookieStore\n *\n * Example:\n *\n *   app.use(mach.session, {\n *     secret: 'the-secret',\n *     secure: true\n *   });\n *\n * Hint: A great way to generate a cryptographically secure session secret from\n * the command line:\n *\n *   $ node -p \"require('crypto').randomBytes(64).toString('hex')\"\n *\n * Note: Since cookies are only able to reliably store about 4k of data, if the\n * session cookie payload exceeds that the session will be dropped.\n */\nfunction session(app, options) {\n  options = options || {};\n\n  if (typeof options === 'string')\n    options = { secret: options };\n\n  var secret = options.secret;\n  var name = options.name || '_session';\n  var path = options.path || '/';\n  var domain = options.domain;\n  var expireAfter = options.expireAfter || 0;\n  var httpOnly = ('httpOnly' in options) ? (options.httpOnly || false) : true;\n  var secure = options.secure || false;\n  var store = options.store || new CookieStore(options);\n\n  if (!secret) {\n    console.warn([\n      'WARNING: There was no \"secret\" option provided to mach.session! This poses',\n      'a security vulnerability because session data will be stored on clients without',\n      'any server-side verification that it has not been tampered with. It is strongly',\n      'recommended that you set a secret to prevent exploits that may be attempted using',\n      'carefully crafted cookies.'\n    ].join('\\n'));\n  }\n\n  return function (conn) {\n    if (conn.session)\n      return conn.call(app); // Don't overwrite the existing session.\n\n    var cookie = conn.request.cookies[name];\n\n    return Promise.resolve(cookie && decodeCookie(cookie, store, secret)).then(function (object) {\n      conn.session = object || {};\n\n      return conn.call(app).then(function () {\n        return Promise.resolve(conn.session && encodeSession(conn.session, store, secret)).then(function (newCookie) {\n          var expires = expireAfter && new Date(Date.now() + (expireAfter * 1000));\n\n          // Don't bother setting the cookie if its value\n          // hasn't changed and there is no expires date.\n          if (newCookie === cookie && !expires)\n            return;\n\n          conn.response.setCookie(name, {\n            value: newCookie,\n            path: path,\n            domain: domain,\n            expires: expires,\n            httpOnly: httpOnly,\n            secure: secure\n          });\n        }, conn.onError);\n      });\n    }, conn.onError);\n  };\n}\n\nmodule.exports = session;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/makeHash.js":"var crypto = require('crypto');\n\n/**\n * Returns a SHA1 hash of the given string.\n */\nfunction makeHash(string) {\n  return crypto.createHash('sha1').update(string).digest('hex');\n}\n\nmodule.exports = makeHash;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/session/CookieStore.js":"var d = require('describe-property');\nvar Promise = require('../../utils/Promise');\n\n/**\n * Client-side storage for sessions using HTTP cookies.\n *\n * Accepts the following options:\n *\n * - expireAfter      The number of seconds after which sessions expire.\n *                    Defaults to 0 (no expiration)\n *\n * Note: Cookies are only able to reliably store about 4k of data. Also, sending\n * and receiving large cookies can have a significant impact on overall server\n * response time (see http://yuiblog.com/blog/2007/03/01/performance-research-part-3/).\n * For these reasons, if you are planning on storing a lot of data in the session\n * you may want to use a server-side storage, such as mach.session.RedisStore.\n */\nfunction CookieStore(options) {\n  options = options || {};\n\n  this.ttl = options.expireAfter\n    ? (1000 * options.expireAfter) // expireAfter is given in seconds\n    : 0;\n}\n\nObject.defineProperties(CookieStore.prototype, {\n\n  load: d(function (value) {\n    var session;\n    try {\n      session = JSON.parse(value);\n    } catch (error) {\n      // Ignore invalid JSON data.\n      return Promise.resolve({});\n    }\n\n    // Verify the session is not expired.\n    if (session._expiry && session._expiry <= Date.now())\n      return Promise.resolve({});\n\n    return Promise.resolve(session);\n  }),\n\n  save: d(function (session) {\n    if (this.ttl)\n      session._expiry = Date.now() + this.ttl;\n\n    return Promise.resolve(JSON.stringify(session));\n  })\n\n});\n\nmodule.exports = CookieStore;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/stack.js":"var d = require('describe-property');\nvar RoutingProperties = require('../utils/RoutingProperties');\nvar createMapper = require('./mapper');\nvar createRouter = require('./router');\n\nfunction mapperCreator(mappings) {\n  return function (app) {\n    app = createMapper(app);\n\n    for (var i = 0, len = mappings.length; i < len; ++i)\n      app.map.apply(app, mappings[i]);\n\n    return app;\n  };\n}\n\nfunction routerCreator(routes) {\n  return function (app) {\n    app = createRouter(app);\n\n    for (var i = 0, len = routes.length; i < len; ++i)\n      app.route.apply(app, routes[i]);\n\n    return app;\n  };\n}\n\n/**\n * A middleware that aids in building complex apps that are fronted by other\n * middleware in a \"middleware stack\". Also provides several other useful methods\n * for request mapping and routing that make this middleware a good choice when\n * working with mach at a high level or when getting started for the first time.\n *\n * Middleware are placed into the stack by calling the `use` method which passes\n * along any additional arguments that it receives directly on to the middleware\n * when the stack is compiled.\n *\n * Other stacks can be \"mounted\" easily at various locations using the `map`\n * method. Routes can be added using `route`, `get`, `post`, etc. When a request\n * is received, all middleware, mappings, and routes run in the order they are\n * defined in the stack, top to bottom.\n *\n *   var app = mach.stack();\n *\n *   app.use(mach.gzip);\n *   app.use(mach.file, __dirname + '/public');\n *\n *   // Use an image server to serve requests that begin\n *   // with /images out of /public/img.\n *   app.map('/images', mach.file('/public/img'));\n *\n *   // Since this call is *after* the call to map, this middleware\n *   // will not run when requests begin with \"/images\".\n *   app.use(mach.params);\n *\n *   app.get('/', function (request) {\n *     return \"The params are: \" + JSON.stringify(request.params);\n *   });\n *\n *   app.post('/posts/:post_id/messages', function (request) {\n *     // ...\n *   });\n *\n *   mach.serve(app);\n *\n * Note: A stack is compiled the first time it is called. When a stack is\n * compiled, all middleware is invoked with the downstream app plus any\n * additional arguments that were passed to the call to stack.use. As long as\n * the stack doesn't change between requests, this happens only once.\n */\nfunction createStack(app) {\n  var layers = [], mappings = [], routes = [];\n  var compiledApp;\n\n  function compile(app) {\n    if (routes.length)\n      app = routerCreator(routes)(app);\n\n    if (mappings.length)\n      app = mapperCreator(mappings)(app);\n\n    var index = layers.length;\n\n    while (index)\n      app = layers[--index].call(this, app);\n\n    return app;\n  }\n\n  function stack(conn) {\n    return conn.call(compiledApp || (compiledApp = compile(app)));\n  }\n\n  Object.defineProperties(stack, {\n\n    /**\n     * Declares that the given `middleware` should be used at the current point\n     * in the stack. Any additional arguments to this function are passed along\n     * to the middleware with the downstream app as the first argument when the\n     * stack is compiled.\n     */\n    use: d(function (middleware) {\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if (mappings.length)\n        layers.push(mapperCreator(mappings.splice(0, mappings.length)));\n\n      if (routes.length)\n        layers.push(routerCreator(routes.splice(0, routes.length)));\n\n      layers.push(function (app) {\n        return middleware.apply(this, [ app ].concat(args));\n      });\n\n      compiledApp = null;\n    }),\n\n    /**\n     * Uses a mapper to map a URL path to an app.\n     */\n    map: d(function (location, app) {\n      mappings.push([ location, app ]);\n      compiledApp = null;\n    }),\n\n    /**\n     * Uses a router to route URLs that match a pattern/method to an app.\n     */\n    route: d(function (pattern, methods, app) {\n      routes.push([ pattern, methods, app ]);\n      compiledApp = null;\n    }),\n\n    /**\n     * Sets the given app as the default for this stack.\n     */\n    run: d(function (downstreamApp) {\n      app = downstreamApp;\n      compiledApp = null;\n    })\n\n  });\n\n  Object.defineProperties(stack, RoutingProperties);\n\n  return stack;\n}\n\nmodule.exports = createStack;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/token.js":"var mach = require('../index');\nvar makeToken = require('../utils/makeToken');\n\nmach.extend(\n  require('../extensions/server')\n);\n\n/**\n * The set of HTTP request methods that are considered safe because they\n * do not alter server data.\n */\nvar SAFE_METHODS = {\n  GET: true,\n  HEAD: true,\n  OPTIONS: true,\n  TRACE: true\n};\n\n/**\n * A middleware that helps to prevent Cross-site Request Forgery attacks by\n * requiring the client to include an authentication token in all form\n * submissions that matches a value stored in the session cookie. See\n * http://www.codinghorror.com/blog/2008/10/preventing-csrf-and-xsrf-attacks.html\n *\n * If the session does not already have an authentication token one is\n * automatically generated and stored in the session. The default session key\n * is \"_token\". All form submissions need to include this value in the \"_token\"\n * parameter, like this:\n *\n *   <form method=\"POST\" action=\"/\">\n *     <input type=\"hidden\" name=\"_token\" value=\"{{session._token}}\">\n *   </form>\n *\n * On the backend, you need to put both mach.session and mach.params in front of\n * mach.token in order for it to be able to retrieve values from the request session\n * and parameters, like this:\n *\n *   app.use(mach.session);\n *   app.use(mach.params);\n *   app.use(mach.token);\n *   app.run(function (conn) {\n *     // The connection authenticated successfully\n *   });\n *\n * Options may be any of the following:\n *\n * - paramName        The name of the request parameter that contains the token\n *                    (i.e. the value of the \"name\" attribute on your <input>).\n *                    Defaults to \"_token\"\n * - sessionKey       The name of the session variable to use to store the token.\n *                    Defaults to \"_token\"\n * - byteLength       The length of the token in bytes. Defaults to 32\n *\n * Note: Non-POST requests are always forwarded to the downstream app regardless of\n * whether or not they contain the token since it is assumed they are not modifying\n * anything and are safe.\n */\nfunction verifyToken(app, options) {\n  options = options || {};\n\n  if (typeof options === 'string')\n    options = { paramName: options };\n\n  var paramName = options.paramName || '_token';\n  var sessionKey = options.sessionKey || '_token';\n  var byteLength = options.byteLength || 32;\n\n  return function (conn) {\n    var session = conn.session, params = conn.params;\n\n    if (!session) {\n      conn.onError(new Error('No session! Use mach.session in front of mach.token'));\n    } else if (!params) {\n      conn.onError(new Error('No params! Use mach.params in front of mach.token'));\n    } else {\n      var token = session[sessionKey];\n\n      // Create a new session token if needed.\n      if (!token)\n        token = session[sessionKey] = makeToken(byteLength);\n\n      if (params[paramName] && params[paramName] === token)\n        return conn.call(app);\n    }\n\n    // If the request is not a POST we assume it's not a form submission\n    // and therefore not modifying anything. Pass it downstream.\n    if (SAFE_METHODS[conn.method] === true)\n      return conn.call(app);\n\n    conn.text(403, 'Forbidden');\n  };\n}\n\nmodule.exports = verifyToken;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/makeToken.js":"var crypto = require('crypto');\n\n/**\n * Returns a cryptographically-secure string containing the\n * given number of bytes.\n */\nfunction makeToken(byteLength) {\n  return crypto.randomBytes(byteLength).toString('hex');\n}\n\nmodule.exports = makeToken;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/proxy.js":"module.exports = function (mach) {\n  mach.createProxy = require('../utils/createProxy');\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/statusText.js":"var d = require('describe-property');\nvar StatusCodes = require('../StatusCodes');\n\nmodule.exports = function (mach) {\n  Object.defineProperties(mach.Connection.prototype, {\n\n    /**\n     * The message that corresponds with the response status code.\n     */\n    statusText: d.gs(function () {\n      return this.status + ' ' + StatusCodes[this.status];\n    })\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/StatusCodes.js":"/**\n * A map of HTTP status codes to their \"status text\".\n */\nmodule.exports = {\n  100: 'Continue',\n  101: 'Switching Protocols',\n  102: 'Processing',                       // RFC 2518, obsoleted by RFC 4918\n  200: 'OK',\n  201: 'Created',\n  202: 'Accepted',\n  203: 'Non-Authoritative Information',\n  204: 'No Content',\n  205: 'Reset Content',\n  206: 'Partial Content',\n  207: 'Multi-Status',                     // RFC 4918\n  300: 'Multiple Choices',\n  301: 'Moved Permanently',\n  302: 'Moved Temporarily',\n  303: 'See Other',\n  304: 'Not Modified',\n  305: 'Use Proxy',\n  307: 'Temporary Redirect',\n  400: 'Bad Request',\n  401: 'Unauthorized',\n  402: 'Payment Required',\n  403: 'Forbidden',\n  404: 'Not Found',\n  405: 'Method Not Allowed',\n  406: 'Not Acceptable',\n  407: 'Proxy Authentication Required',\n  408: 'Request Time-out',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length Required',\n  412: 'Precondition Failed',\n  413: 'Request Entity Too Large',\n  414: 'Request-URI Too Large',\n  415: 'Unsupported Media Type',\n  416: 'Requested Range Not Satisfiable',\n  417: 'Expectation Failed',\n  418: \"I'm a teapot\",                     // RFC 2324\n  422: 'Unprocessable Entity',             // RFC 4918\n  423: 'Locked',                           // RFC 4918\n  424: 'Failed Dependency',                // RFC 4918\n  425: 'Unordered Collection',             // RFC 4918\n  426: 'Upgrade Required',                 // RFC 2817\n  428: 'Precondition Required',            // RFC 6585\n  429: 'Too Many Requests',                // RFC 6585\n  431: 'Request Header Fields Too Large',  // RFC 6585\n  500: 'Internal Server Error',\n  501: 'Not Implemented',\n  502: 'Bad Gateway',\n  503: 'Service Unavailable',\n  504: 'Gateway Timeout',\n  505: 'HTTP Version Not Supported',\n  506: 'Variant Also Negotiates',          // RFC 2295\n  507: 'Insufficient Storage',             // RFC 4918\n  509: 'Bandwidth Limit Exceeded',\n  510: 'Not Extended',                     // RFC 2774\n  511: 'Network Authentication Required'   // RFC 6585\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/callApp.js":"var Connection = require('../Connection');\nvar Promise = require('./Promise');\n\n/**\n * Creates a new Connection using the given options and sends\n * the request to the given app. Returns a promise for the connection\n * object when the response is received.\n *\n * Options may be any of the Connection options, plus the following:\n *\n * - binary     By default the response content is buffered and stored\n *              in the responseText property of the connection. Set this\n *              option true to disable this behavior.\n * - maxLength  The maximum length of the response content to accept.\n *              This option has no effect when \"binary\" is true. By\n *              default there is no maximum length.\n * - encoding   The encoding to use to decode the response body. This\n *              option has no effect when \"binary\" is true. By default\n *              the encoding is whatever was specified in the Content-Type\n *              header of the response.\n *\n * If a modifier function is provided, it will have a chance to modify\n * the Connection object immediately before the request is made.\n */\nfunction callApp(app, options, modifier) {\n  options = options || {};\n\n  var c = new Connection(options);\n\n  return Promise.resolve(modifier ? modifier(c) : c).then(function (conn) {\n    if (conn == null || !(conn instanceof Connection))\n      conn = c;\n\n    return conn.call(app).then(function () {\n      if (options.binary)\n        return conn;\n\n      return conn.response.stringifyContent(options.maxLength, options.encoding).then(function (content) {\n        conn.responseText = content;\n        return conn;\n      });\n    });\n  });\n}\n\nmodule.exports = callApp;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/default-browser.js":"/**\n * The default extension for browser environments.\n */\nmodule.exports = function (mach) {\n  mach.extend(require('./client'));\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/extensions/submit.js":"var createContent = require('../multipart/createContent');\n\nfunction forEach(list, callback) {\n  for (var i = 0, len = list.length; i < len; ++i)\n    callback.call(list, list[i], i, list);\n}\n\nfunction getFieldType(node) {\n  return node.nodeName.toUpperCase() === 'INPUT' ? node.type.toUpperCase() : 'TEXT';\n}\n\nfunction addParam(params, name, value) {\n  if (!params[name]) {\n    params[name] = value;\n  } else if (Array.isArray(params[name])) {\n    params[name].push(value);\n  } else {\n    params[name] = [ params[name], value ];\n  }\n}\n\nfunction getParams(form) {\n  var params = {};\n\n  forEach(form.elements, function (element) {\n    if (!element.hasAttribute('name'))\n      return;\n\n    var name = element.name;\n    var type = getFieldType(element);\n\n    if (type === 'FILE' && element.files.length > 0) {\n      forEach(element.files, function (file) {\n        addParam(params, name, file);\n      });\n    } else if ((type !== 'RADIO' && type !== 'CHECKBOX') || element.checked) {\n      addParam(params, name, element.value);\n    }\n  });\n\n  return params;\n}\n\nmodule.exports = function (mach) {\n  mach.extend(require('./client'));\n\n  /**\n   * Submits the given form as binary data via XMLHttpRequest using\n   * the form's action, method, and encoding, and returns a promise for\n   * the connection object. This function is able to submit forms as\n   * either application/x-www-form-urlencoded or multipart/form-data.\n   *\n   * Note: Only GET and POST methods are supported, as per the HTML spec.\n   * If you need to use another method, try using a hidden `_method` field\n   * and mach.methodOverride on the server.\n   *\n   * See also http://www.w3.org/TR/html401/interact/forms.html#h-17.13.1\n   */ \n  mach.submit = function (form) {\n    var action = form.action;\n    var method = form.method.toUpperCase();\n    var contentType = form.enctype;\n    var params = getParams(form);\n\n    if (method === 'GET')\n      return mach.get({ url: action, params: params });\n\n    if (contentType !== 'multipart/form-data')\n      return mach.post({ url: action, params: params });\n\n    var boundary = '--------------------------------' + Date.now().toString(16);\n\n    return mach.post({\n      url: action,\n      headers: {\n        'Content-Type': contentType + '; boundary=' + boundary\n      },\n      content: createContent(params, boundary)\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/multipart/createContent.js":"/* jshint -W058 */\nvar Stream = require('bufferedstream');\nvar Promise = require('../utils/Promise');\nvar readFile = require('../utils/readFile');\nvar File = require('../utils/File');\n\nfunction createHeaders(name, filename, type) {\n  var header = 'Content-Disposition: form-data; name=\"' + name + '\"';\n\n  if (filename)\n    header += '; filename=\"' + filename + '\"';\n\n  if (type)\n    header += '\\r\\nContent-Type: ' + type;\n\n  return header + '\\r\\n\\r\\n';\n}\n\n/**\n * Creates and returns a binary stream of multipart content produced\n * from the given params. Param values may be a string, binary, or File\n * object, or an array of any of those types.\n */\nfunction createContent(params, boundary) {\n  var content = new Stream;\n\n  // Use a promise chain to write all fields to the content\n  // stream in the same order they appear in params.\n  var promise = Promise.resolve();\n\n  function appendContent(name, value) {\n    if (value instanceof File) {\n      var p = readFile(value);\n\n      promise = promise.then(function () {\n        content.write('--' + boundary + '\\r\\n' + createHeaders(name, value.name, value.type));\n\n        return p.then(function (chunk) {\n          content.write(chunk);\n          content.write('\\r\\n');\n        });\n      });\n    } else {\n      promise = promise.then(function () {\n        content.write('--' + boundary + '\\r\\n' + createHeaders(name));\n        content.write(value);\n        content.write('\\r\\n');\n      });\n    }\n  }\n\n  var param, i;\n  for (var name in params) {\n    if (params.hasOwnProperty(name)) {\n      param = params[name];\n\n      if (Array.isArray(param)) {\n        for (i = 0, len = param.length; i < len; ++i)\n          appendContent(name, param[i]);\n      } else {\n        appendContent(name, param);\n      }\n    }\n  }\n\n  promise.then(function () {\n    content.end('--' + boundary + '--\\r\\n');\n  }, function (error) {\n    content.emit('error', error);\n  });\n\n  return content;\n}\n\nmodule.exports = createContent;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/readFile.js":"var fs = require('fs');\nvar Promise = require('./Promise');\n\nfunction readFile(file) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(file.path, function (error, data) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nmodule.exports = readFile;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/File-browser.js":"module.exports = window.File;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/parseURL-browser.js":"var ORIGIN_MATCHER = /^(https?:)\\/\\/(?:([^@]+)@)?([^/:]+)(?::(\\d+))?/;\n\nfunction parseURL(url) {\n  var origin = ORIGIN_MATCHER.exec(url) || {};\n\n  var anchor = document.createElement('a');\n  anchor.href = url;\n\n  return {\n    protocol: origin[1] || null,\n    auth: origin[2] || null,\n    hostname: origin[3] || null,\n    port: origin[4] || null,\n    pathname: anchor.pathname,\n    search: anchor.search,\n    hash: anchor.hash\n  };\n}\n\nmodule.exports = parseURL;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/readFile-browser.js":"/* jshint -W058 */\nvar Promise = require('./Promise');\n\nfunction readFile(file) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader;\n\n    reader.onerror = reject;\n    reader.onload = function () {\n      resolve(new Uint8Array(reader.result));\n    };\n\n    reader.readAsArrayBuffer(file);\n  });\n}\n\nmodule.exports = readFile;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/utils/sendRequest-browser.js":"/* jshint -W058 */\nvar XMLHttpRequest = window.XMLHttpRequest;\nvar Stream = require('bufferedstream');\nvar AbortablePromise = require('./AbortablePromise');\n\nfunction copyStatusAndHeaders(xhr, conn) {\n  conn.response.headers = xhr.getAllResponseHeaders();\n  conn.status = xhr.status;\n  return conn.status;\n}\n\nfunction getContent(xhr) {\n  var type = String(xhr.responseType).toLowerCase();\n\n  if (type === 'blob')\n    return xhr.responseBlob || xhr.response;\n\n  if (type === 'arraybuffer')\n    return xhr.response;\n\n  if (typeof VBArray === 'function')\n    return new VBArray(client.responseBody).toArray(); // IE9\n\n  return xhr.responseText;\n}\n\nfunction pipeContent(xhr, stream, offset) {\n  var content = getContent(xhr);\n\n  if (content != null) {\n    if (content.toString().match(/ArrayBuffer/)) {\n      stream.write(new Uint8Array(content, offset));\n      return content.byteLength;\n    }\n\n    if (content.length > offset) {\n      stream.write(content.slice(offset));\n      return content.length;\n    }\n  }\n\n  return offset;\n}\n\nfunction enableBinaryContent(xhr) {\n  if ('responseType' in xhr) {\n    xhr.responseType = 'arraybuffer'; // XHR2\n  } else if ('overrideMimeType' in xhr) {\n    xhr.overrideMimeType('text/plain; charset=x-user-defined'); // XHR\n  } else {\n    xhr.setRequestHeader('Accept-Charset', 'x-user-defined'); // IE9\n  }\n}\n\nfunction enableCredentials(xhr) {\n  if ('withCredentials' in xhr)\n    xhr.withCredentials = true;\n}\n\nvar READ_HEADERS_RECEIVED_STATE = true;\nvar READ_LOADING_STATE = true;\n\nfunction sendRequest(conn, location) {\n  return new AbortablePromise(function (resolve, reject, onAbort) {\n    var xhr = new XMLHttpRequest;\n    xhr.open(conn.method, location.href, true);\n\n    enableBinaryContent(xhr);\n\n    if (conn.withCredentials)\n      enableCredentials(xhr);\n\n    var request = conn.request;\n    var headers = request.headers;\n\n    if (headers)\n      for (var headerName in headers)\n        if (headers.hasOwnProperty(headerName))\n          xhr.setRequestHeader(headerName, headers[headerName]);\n\n    var content = conn.response.content = new Stream;\n    var offset = 0, status;\n\n    function tryToResolve() {\n      if (!status && (status = copyStatusAndHeaders(xhr, conn)) > 0)\n        resolve(conn);\n    }\n\n    xhr.onreadystatechange = function () {\n      if (xhr.error)\n        return; // readystatechange triggers before error.\n\n      if (xhr.readyState === 2 && READ_HEADERS_RECEIVED_STATE) {\n        try {\n          tryToResolve();\n        } catch (error) {\n          READ_HEADERS_RECEIVED_STATE = false;\n        }\n      } else if (xhr.readyState === 3 && READ_LOADING_STATE) {\n        try {\n          tryToResolve();\n          offset = pipeContent(xhr, content, offset);\n        } catch (error) {\n          READ_LOADING_STATE = false;\n        }\n      } else if (xhr.readyState === 4) {\n        tryToResolve();\n        pipeContent(xhr, content, offset);\n        content.end();\n      }\n    };\n\n    xhr.onerror = function (event) {\n      // Sometimes XHR fails due to CORS constraints. In those cases\n      // we don't have any extra information here, unfortunately.\n      // See http://stackoverflow.com/questions/4844643/is-it-possible-to-trap-cors-errors\n      reject(event.error || new Error('XMLHttpRequest failed'));\n    };\n\n    onAbort(function () {\n      try {\n        xhr.abort();\n      } catch (error) {\n        // Not a problem.\n      }\n\n      resolve();\n    });\n\n    request.bufferContent().then(function (chunk) {\n      xhr.send(chunk);\n    }).then(undefined, reject);\n  });\n}\n\nmodule.exports = sendRequest;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/session/MemoryStore.js":"var d = require('describe-property');\nvar makeToken = require('../../utils/makeToken');\nvar Promise = require('../../utils/Promise');\n\nfunction makeUniqueKey(sessions, keyLength) {\n  var key;\n  do {\n    key = makeToken(keyLength);\n  } while (sessions[key]);\n\n  return key;\n}\n\nfunction pruneStore(store, interval) {\n  var timer = setInterval(function () {\n    var now = Date.now();\n\n    var session;\n    for (var key in store.sessions) {\n      session = store.sessions[key];\n\n      if (session._expiry && session._expiry < now)\n        store.purge(key);\n    }\n  }, interval);\n\n  // Don't let this timer keep the event loop running.\n  timer.unref();\n\n  return timer;\n}\n\n/**\n * Basic server-side storage for sessions that exist within a single process.\n * This should never be used in production, but can be useful in development\n * and testing scenarios when there is only a single server instance.\n *\n * Accepts the following options:\n *\n * - keyLength        The length (in bytes) that will be used for unique cache keys.\n *                    Defaults to 32\n * - purgeInterval    The interval (in milliseconds) at which the cache is\n *                    purged of expired sessions. Defaults to 5000\n * - expireAfter      The number of seconds after which sessions expire.\n *                    Defaults to 0 (no expiration)\n */\nfunction MemoryStore(options) {\n  options = options || {};\n\n  this.sessions = {};\n  this.timer = pruneStore(this, options.purgeInterval || 5000);\n  this.keyLength = options.keyLength || 32;\n  this.ttl = options.expireAfter\n    ? (1000 * options.expireAfter) // expireAfter is given in seconds\n    : 0;\n}\n\nObject.defineProperties(MemoryStore.prototype, {\n\n  load: d(function (value) {\n    var session = this.sessions[value];\n\n    if (!session)\n      return Promise.resolve({});\n\n    // Verify the session is not expired.\n    if (session._expiry && session._expiry <= Date.now())\n      return Promise.resolve({});\n\n    return Promise.resolve(session);\n  }),\n\n  save: d(function (session) {\n    var key = session._id;\n    if (!key)\n      key = session._id = makeUniqueKey(this.sessions, this.keyLength);\n\n    if (this.ttl)\n      session._expiry = Date.now() + this.ttl;\n\n    this.sessions[key] = session;\n\n    return Promise.resolve(key);\n  }),\n\n  purge: d(function (key) {\n    if (key) {\n      delete this.sessions[key];\n    } else {\n      this.sessions = {};\n    }\n  }),\n\n  destroy: d(function () {\n    delete this.sessions;\n\n    if (this.timer) {\n      clearInterval(this.timer);\n      delete this.timer;\n    }\n  })\n\n});\n\nmodule.exports = MemoryStore;\n","/home/travis/build/npmtest/node-npmtest-mach/node_modules/mach/modules/middleware/session/RedisStore.js":"var d = require('describe-property');\nvar redis = require('redis');\nvar makeToken = require('../../utils/makeToken');\nvar Promise = require('../../utils/Promise');\nvar parseURL = require('../../utils/parseURL');\n\nfunction sendCommand(client, command, args) {\n  args = args || [];\n\n  return new Promise(function (resolve, reject) {\n    client.send_command(command, args, function (error, value) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(value);\n      }\n    });\n  });\n}\n\nfunction makeUniqueKey(client, keyLength) {\n  var key = makeToken(keyLength);\n\n  // Try to set an empty string to reserve the key.\n  return sendCommand(client, 'setnx', [ key, '' ]).then(function (result) {\n    if (result === 1)\n      return key; // The key was available.\n\n    return makeUniqueKey(client, keyLength); // Try again.\n  });\n}\n\n/**\n * Server-side storage for sessions using Redis.\n *\n * Options may be any of the following:\n *\n * - url              The URL of the Redis instance\n * - keyLength        The length (in bytes) that will be used for unique\n *                    cache keys. Defaults to 32\n * - expireAfter      The number of seconds after which sessions expire.\n *                    Defaults to 0 (no expiration)\n *\n * Additionally, all options are passed through to `redis.createClient`.\n *\n * Example:\n *\n *   var RedisStore = require('mach/middleware/session/RedisStore');\n *\n *   app.use(mach.session, {\n *     store: new RedisStore({ url: 'redis://127.0.0.1:6379' })\n *   });\n *\n * Note: This store always checks for availability of keys in Redis before\n * using them, so it should be safe to use alongside other programs that are\n * using the same database. However, if you purge the store of all keys it will\n * issue a FLUSHDB command to the database, so be careful. This operation never\n * happens automatically.\n */\nfunction RedisStore(options) {\n  options = options || {};\n\n  this.options = options;\n  this.keyLength = options.keyLength || 32;\n  this.ttl = options.expireAfter\n    ? (1000 * options.expireAfter) // expireAfter is given in seconds\n    : 0;\n}\n\nObject.defineProperties(RedisStore.prototype, {\n\n  getClient: d(function () {\n    if (!this._client) {\n      var options = this.options;\n\n      var hostname, port;\n      if (typeof options.url === 'string') {\n        var parsedURL = parseURL(options.url);\n        hostname = parsedURL.hostname;\n        port = parsedURL.port;\n      }\n\n      this._client = redis.createClient(port, hostname, options);\n    }\n\n    return this._client;\n  }),\n\n  load: d(function (value) {\n    return sendCommand(this.getClient(), 'get', [ value ]).then(function (json) {\n      return json ? JSON.parse(json) : {};\n    });\n  }),\n\n  save: d(function (session) {\n    var client = this.getClient();\n    var keyLength = this.keyLength;\n    var ttl = this.ttl;\n\n    return Promise.resolve(session._id || makeUniqueKey(client, keyLength)).then(function (key) {\n      session._id = key;\n\n      var json = JSON.stringify(session);\n\n      var promise;\n      if (ttl) {\n        promise = sendCommand(client, 'psetex', [ key, ttl, json ]);\n      } else {\n        promise = sendCommand(client, 'set', [ key, json ]);\n      }\n\n      return promise.then(function () {\n        return key;\n      });\n    });\n  }),\n\n  purge: d(function (key) {\n    if (key)\n      return sendCommand(this.getClient(), 'del', [ key ]);\n\n    return sendCommand(this.getClient(), 'flushdb');\n  }),\n\n  destroy: d(function () {\n    return sendCommand(this.getClient(), 'quit');\n  })\n\n});\n\nmodule.exports = RedisStore;\n"}